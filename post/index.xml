<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Think in Hualet</title>
    <link>https://hualet.org/post/</link>
    <description>Recent content in Posts on Think in Hualet</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sun, 10 Mar 2019 14:11:28 +0800</lastBuildDate>
    
	<atom:link href="https://hualet.org/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>深度数据盘和FUSE文件系统</title>
      <link>https://hualet.org/blog/2019/03/10/%E6%B7%B1%E5%BA%A6%E6%95%B0%E6%8D%AE%E7%9B%98%E5%92%8Cfuse%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</link>
      <pubDate>Sun, 10 Mar 2019 14:11:28 +0800</pubDate>
      
      <guid>https://hualet.org/blog/2019/03/10/%E6%B7%B1%E5%BA%A6%E6%95%B0%E6%8D%AE%E7%9B%98%E5%92%8Cfuse%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</guid>
      <description>​ 说起FUSE，大概很早之前就知道了，但是写文件系统这种东西，大概一辈子也没几次机会会用到，所以当时也没怎么研究，直到最近遇到一个“扭曲”的需求……
​ 这个需求是这样的。在深度系统的安装器中，有一个全盘安装的功能，这个功能看起来非常简单：扔一块全新的或者老旧的硬盘给安装器，只需一杯咖啡的功夫，你的系统也就能优雅地躺在你的硬盘上了。然而，其中有一个处心积虑，哦不，深思熟虑的细节设定，就是假如你硬盘够大，安装器就会给你多分出一个分区：数据盘。
​ 据说数据盘的主要作用是让用户存放数据文件，也就是以前用Windows的时候D盘或者E盘等的作用，放点图片、下点片之类的。用户重装系统的时候，也可以方便的做数据迁移。不过鉴于之前我们的一些客户对文件权限的设计不太理解，经常莫名其妙就出权限文件，所以，这个数据盘大概隐含了两个阴性需求：
 文件权限不要太严格； 文件权限不要太严格……  第一次尝试 ​ 收到需求的你肯定想，Linux（类Unix）把用户权限、文件权限划分地这么好，虽然也不算天衣无缝吧，但是回到上古时代的没有文件权限这种事，简直就是历史的倒退么……然而作为一名优秀的程序员，怎么能不理解这种为了用户使用方便，宁愿自己背负骂名的行为呢，所以我们选择了不抵抗。另外，为了这个盘可以被双系统的Windows读到，当时我们毅然选择了NTFS作为数据盘的分区格式。
​ 然而，过了一段时间。
 社区用户：我的硬盘发热好厉害呀，是不是这个NTFS分区…… 商业伙伴：这个NTFS文件系统的有点不清真啊……  ​ 这显然没有达到我们预期的目的嘛，必须想办法搞定啊。数据盘这个需求就开始了它的扭曲之旅。
第二次尝试 ​ 如果不使用NTFS，那就在ext4上面做文章咯？在网络上搜索了半天，也没有发现什么好的方式，要么就是chmod -R xxx 这种，要么就是 chown……然后突然想到之前同事提到过的ACL（限于篇幅和主题，就不展开了），就研究了一下，果然还就能解决问题，两条命令：
$ setfacl -d -m &amp;quot;g:sudo:rwx&amp;quot; /xxx $ setfacl -m &amp;quot;g:sudo:rwx&amp;quot; /xxx  ​ 其中的/xxx就是数据盘的挂载点，第一行命令设定了挂载点目录的默认ACL规则是：所有sudo组的用户可以对文件有rwx操作权限，第二句是设定了挂载点目录的ACL规则是：所有sudo组的用户可以对文件有rwx操作权限，好像看起来没有什么区别，其实不同的地方在于第一行命令设定的是目录的默认ACL规则，而第二行命令设定的是目录本身的ACL规则。设定了默认规则以后目录里面新创建的文件或者文件夹就会继承这个规则，如果只设置目录的ACL规则，则新文件和子目录不会继承这些ACL规则；如果只设置目录的默认ACL规则，而不设置目录本身的ACL规则，则目录本身没有ACL规则生效。
​ 虽然这个设定感觉有点让人发晕，但是好歹功能都实现了呀，一切都看似那么美好。
​ 然而程序员的所有美好都怕测试这种物种，测试有一天突然发现：“咦？系统里面的A用户放在数据盘里面的文件怎么B用户无法访问？”程序员就多了个BUG……
​ 经过调试，发现一种神奇的现象：Linux（可能其他系统也是）对ACL的处理有点奇怪，假如在拥有ACL规则的对象（文件或者目录）上进行chmod操作，那么chmod 会对对象的ACL规则造成影响，影响的结果就是对象虽然有ACL规则，但是ACL的有效值会变成chmod要达成的效果。
​ 举个例子，假如文件原来的ACL规则如下：
$ getfacl testacl # file: testacl # owner: hualet # group: hualet user::rw- group::r-- group:sudo:rwx mask::rwx other::r--  ​ 文件的权限是644，但是sudo组的用户有rwx权限。这时候如果我们使用chmod 700 testacl修改一下文件的权限，再次查看文件的ACL会变成：</description>
    </item>
    
    <item>
      <title>《走向共和》观后感</title>
      <link>https://hualet.org/blog/2019/03/03/%E8%B5%B0%E5%90%91%E5%85%B1%E5%92%8C%E8%A7%82%E5%90%8E%E6%84%9F/</link>
      <pubDate>Sun, 03 Mar 2019 14:42:08 +0800</pubDate>
      
      <guid>https://hualet.org/blog/2019/03/03/%E8%B5%B0%E5%90%91%E5%85%B1%E5%92%8C%E8%A7%82%E5%90%8E%E6%84%9F/</guid>
      <description>​ 断断续续地从2018年下半年开始看《走向共和》，到今天算是看完了。
​ 最开始知道这部电视剧，还是看到网友Tualatrix在Twitter上的推荐，不过当时看电视封面中最大头像的是孙中山，不太感冒，所以就没有怎么好好看，一般都是边玩游戏边看，但是看了几集以后顿时觉得过瘾，一共58集的电视剧把中国从甲午中日战争到护国、护法运动的历史算是做了非常精彩的演绎，而且电视剧的布景正是我喜欢的类似《大明王朝1566》（后来才知道原来是同一个导演张黎）、《乔家大院》、《大染坊》、《六龙飞天》那种朴素而又显得真实的布景，再加上对剧中主角的性格塑造非常细致，基本上推翻了以前从教科书中得到的对几个主角的评价，愈发觉得着实的喜欢。
主角们 ​ 因为剧情比较宏大，所以总共算是有四个主角，按照清政府倒台作为中间线，前半段主要是李鸿章主角、后半段主要是袁世凯主角，慈禧和孙中山贯穿其中，只是作为两段历史的领袖人物，慈禧要比孙中山戏份多得多，对剧情也重要的多（个人观点）。
李鸿章 ​ 这部剧之所以吸引我，大概就是前期对李鸿章的塑造大大刷新了我对他的认识，这哪是什么教科书中的卖国贼，片中的李鸿章分明是一个讲求实干、精于世故、老成谋国的人，苦苦支撑国事的偏于正面的形象：
 为北洋水师的军费与朝中以翁同龢为代表的清流派争斗； 顾全大局（争取本来敌视他的南洋大臣张之洞，这点感觉比他的老师曾国藩对待左宗棠有手段）； 有点跋扈，但是也对自己认清的现实非常坚持，视满朝的非议诋毁如过耳云烟； 马关和谈时尽其所能与日本人周旋（甚至把自己在日本被刺当作谈判筹码，与伊藤博文讨价还价，苦苦哀求砍掉2000万作为回国的盘缠，真是叫人揪心……）； 对政局了若指掌，戊戌变法时跑到欧洲考察，实际是为了躲避帝后之争； 辛丑和谈的时候表现出的老道； 签订辛丑条约时与列强的周旋（李鸿章拦住了一起主持议和的庆亲王，而只签上了自己的名字。说：王爷还年轻，这种要背千古骂名的事还是由我这老朽担当了吧)。  ​ 李鸿章在政治上是一个高级玩家，狡猾地如狐狸一般，但是作为一个士大夫，还是表现出了那种家国天下的情怀，终然洞穿官场一切的潜规则，还是尽自己最大的努力来维持局面。作为晚清洋务运动的领导者之一，他可以说是举步维艰，但是仍然知难而上，运用自己的政治智慧沉着应对每个难关。
金句  “身怀利器，杀心自起，慎而重之！” “一代人只能做一代人的事情。”  评价 ​ 李鸿章作为一个天才，只能说生错了国家、生错了时代，为国苦苦经营，最后却落得个卖国贼的名分。
​ 用剧中伊藤博文的原话来说：“伊藤不才，然何其幸哉，能驻足日本之地，此乃立宪国之地，且举国人才辈出；李鸿章大才，然何其不幸，为政于中国之地，其乃绝对专制之地，故而有才化无才，且举国人才，一遇专制俱为奴才。”
袁世凯 ​ 我记得以前我的一位历史老师曾经讲过一个笑话：“袁世凯一生只做过一件好事，就是他死了”，当时全班大笑，因为在小时候的电视剧里面，真没有看到过哪个剧里面有袁世凯，但是是一个正面形象的，坏人死了的才是喜剧嘛。
​ 但是这部剧里面的袁世凯，太复杂，根本无法单一评价，正面看：
 实干家； 勇武果断； 聪明； 能力出众； 讲义气（对小站练兵的弟兄、对英子）； ……  ​ 从反面看：
 反叛者；
 依附权贵；
 阴险狡诈（杀了赵秉钧）；
 破坏共和；
 ……
  ​ 从一个成年人的视角，可能他做得很多事情，都对得起最后那句“我们这辈子，没有白活啊。”但是，作为一个统治者，为了自己的权利欲望去玩弄国家政体，确实只能说是历史的罪人……
金句  “这就是政治，可以犯罪，但不可以犯错。” “这做事也罢，当官儿也罢，千万不能搞一锤子的买卖，不能过河就拆桥，你得老想着还有下一次，只要还有能力就要架桥铺路，不然那就是短视，做人没出息，办事也总是失败。”  评价 ​ 从我个人来说，我还是挺佩服他的，实干家又懂得政治规则，从一个痞子最终混成了帝国的皇帝，不可以说他没有才干。但最终，一招不慎，满盘皆输，明明什么都看得透彻，但是就是抵不住自己对权力的欲望，落得个众矢之的的下场。
​ 用孙中山对他的评价，原话忘了，大意是“袁世凯本质上就是一个攀附权贵的人，先是李鸿章，接着是荣禄和张之洞，还有最后的庆王爷，他迟早是要当皇帝的，这是他的心病。只是仙子啊满世界都在搞宪政、搞共和，袁世凯非要当皇帝，这历史的潮流是不允许的。“</description>
    </item>
    
    <item>
      <title>WPS中的字体名</title>
      <link>https://hualet.org/blog/2019/01/14/wps%E4%B8%AD%E7%9A%84%E5%AD%97%E4%BD%93%E5%90%8D/</link>
      <pubDate>Mon, 14 Jan 2019 18:31:08 +0800</pubDate>
      
      <guid>https://hualet.org/blog/2019/01/14/wps%E4%B8%AD%E7%9A%84%E5%AD%97%E4%BD%93%E5%90%8D/</guid>
      <description>今天又被 fontconfig 坑到了……仔细想想，半年到一年前我还对 fontconfig 狗屁不通呢，而现在我已经被 fontconfit 坑了有几次了，这印证了一个真理：“只要你足够迟钝，世界就是美好的，一旦你有了某种能力，麻烦就会找到你”——这只是个玩笑，事实上不管你有没有能力，现实都不会让你好过 😈
在这些坑里面，有两个是跟今天主题相关的，也就是关于WPS中字体名称的两个问题：
 WPS 字体列表中中文字体在中文环境下不显示中文名（比如系统里面有宋体，列表里面显示 SimSun）； WPS 设置段落字体（中文字体）后，工具栏显示的字体为英文名（比如你设置一段文字是宋体，但是标题栏显示的仍然是SimSun）  这两个问题有点像，但是却不是同一个问题（也不只是WPS有问题，而是WPS对字体的需求比较多）：
第一个问题原先是 论坛用户报告 的（实际上刘老大也报过，不过被自动忽略了😂），论坛用户又报过来以后，大家看用户的报告太详细了，感动得一塌糊涂，顿时解决问题的动力都有了。我也折腾了大半天，不过脑袋里面一直有一个同事的声音：那是字体有问题！我也挺赞同的：盗版的字体，不靠谱很正常……所以，我就考虑能不能给字体做一些别名啥的，比如 SimSun 就叫 宋体……当然了最后就是玩了一下 fontconfig 的配置以后，默默就放弃了。
最后经过 @felixonmars 同学的排查，发现是上游的一个 bug ，而且已经修复，所以赶紧更了一波，解决了这个问题。
本以为皆大欢喜了，今天又有客户报过来 bug，说 Windows 上写好的文档，调整好的字体，跑到deepin下字体就不对了，废了老大的劲儿才又调好，其中就提到了选择方正字库里面的字体，显示的不是中文字体名称的问题。
怎么说呢，幸亏我脑子不好，不记得之前已经解决过中文字体名显示为英文的问题，要不然得跟客户和老板掰扯一会儿，我只记得字体的中英文名字好像是有点问题，所以默默赶紧去看了一下，还真真的有问题。
因为 DDE 并没有设置过多的 fontconfig 配置，所以我相信这不是 DDE 的问题，但是又觉得对于一个文字处理软件来说，如果这么重要的功能都有 BUG，我真不信 WPS 的人还能坐得住，所以就想试一下在 Ubuntu 下 WPS 的这个行为是否正确。刚好年前 ElementryOS 发新版的时候尝鲜装了一个在测试机器上，所以很快切进去下了一个 WPS 安装上，从一个正版的网站上下载了一个盗版的宋体，试了一下，果然踏马的是好的……
理性的我用事实证明了感性的我是错误的，气氛一度很尴尬。
更让人尴尬的是，我也不知道这是怎么回事。但是，无巧不成书，就在这种尴尬氛围的笼罩下，我鬼使神差地在 ElementryOS （太长了，下面简称 EOS ）上运行了 fc-match 宋体 这个命令，而且很神奇的发现输出的 simsun.ttf: &amp;quot;宋体&amp;quot; &amp;quot;Regular&amp;quot; 跟 deepin 下同样命令输出的 simsun.ttf: &amp;quot;SimSun&amp;quot; &amp;quot;Regular&amp;quot; 不太一样，这可把我乐坏了——要知道一个稍微复杂点的图形软件，打开 fontconfig 的调试以后，输出就是很可怕的，更别说 WPS！别问我是怎么知道的，回忆起来都是泪。但是现在使用 fc-match 就能重现的问题（我打心底认为这俩是同一个问题），调试起来就比较简单了。</description>
    </item>
    
    <item>
      <title>2018 年终总结</title>
      <link>https://hualet.org/blog/2019/01/03/2018-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</link>
      <pubDate>Thu, 03 Jan 2019 19:10:14 +0800</pubDate>
      
      <guid>https://hualet.org/blog/2019/01/03/2018-%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</guid>
      <description>2018 年也不知道为啥过得这么快，似乎“嗖”的一下就过完了，但是仔细回想一下，还是有不少事、不少感想值得留存的，所以赶紧用文字记录下，不然以我的健忘性格，不用到明年的今天，我就不会再记得 2018 年我做了什么、经历了什么和有什么感悟了。惨痛的教训比如 2017， 没有总结，我看了 2016年终总结 甚至不知道我的 2017 相比 2016 是否有进步、有没有按照规划去做了对的事情。所以在这个时间点，就算是年终刚好出去参加同学的婚礼了，也在火车上抽了时间做了脑图，整理了一年下来的总结。
读书 总的来说18年读的书不算多，甚至可以用少来形容，不过总归还有些感悟，记录下来权做以后翻看旧书需要的介绍了。
 《南渡北归》  拖拖拉拉终于几乎看完了全本，只是到国民党退到台湾以后，顿时有一种很丧的气氛在里面（不知道是书还是当时看的我），所以后面基本上就没怎么看了。
对于整本书的评价还是很高的，革命/战乱的年代，杂糅这知识分子的热忱、浪漫、坚毅、吃苦耐劳，沉入其中，感受每个人面对的挣扎和选择，对于一个人对人生和价值观的思考还是非常有促进作用的。
像《老残游记》和《浮生六记》一样，如果有机会，我还会再读几遍。
 《技术管理之巅》  技术管理书，因为很贴近实际，所以显得比较接地气。
在看这本书的过程中想通了技术和管理其实是可以很好融合在一起，而不是互相对立的。
 《把生命浪费在美好的事物上》  原以为是类似汪曾祺的哪些小散文的书，但是完全被吴晓波起的书字给骗了。把生命浪费在美好的事物上，你得先跟吴晓波一样有钱 :P
同上本书，这本书让我知道了“铜臭气”和“书呆子气”可以同时存在于一个人身上，并且很好地共存。
 《曾国藩的正面与侧面》  青春期的时候，可能是热血漫画看多了，我总是喜欢认为自己是个“天才”，但是随着年龄增长，我越往后越发现我对于“天才”和“聪明”的需求越来越弱，反而是对“勤”和“恒”的需求越来越多。这本书并没有教会我做什么，而是加深了我早已有的很多想法，让我更知道如何为人和处事。
 《原则》  忘记这本书是什么时候引起风潮的，似乎一时间所有的人都在看这本书。不过我还是因为懒没有看。等过了一段时间有次在火车上没事干，想找一本书看看就选择了这本书。
初看还是很有同感的，尤其是生活部分（其实就像作者说得，前面哪些他个人的经历，其实没有什么特别有意思的地方）的一些原则，我当时甚至想给深度的开发同事也弄一个 深度开发者行事原则 的，但是碍于这个东西实在不好讲，因为每个人本身的认知程度千差万别，想一下子拉齐到同一水平很不现实，所以一拖两拖，就废掉了。
不过我还是因此养成了一个把我在一些特殊时刻想到的一些感受和想法记录下来沉淀的习惯，收获也算不少吧。
 《白夜行》  纯娱乐，读得相当快，好像是一两周之内读完的（这已经是我读书的最快水准）。读这本书是因为偶然一次机会在一个便利店看到一个《解忧杂货店》的舞台剧广告，上面写着“日本作家东野圭吾作品”，当时我就傻眼了——《解忧杂货店》不是村上春树的作品么？？？再三确认以后，我决定再读一本东野圭吾的作品，以示歉意，所以就选了《白夜行》。
书中的故事相当粗暴，但是很吸引人，就是那种“我已经猜到答案了，你快点告诉我是不是这样”一路走下去的感觉。
 《见识》  吴军老师的书，都是干货的方法论合集。
按道理说一般说外企大佬写得书，多半是鸡汤（至少我认为是这样），但是吴军老师的书里面还是有很多大智慧。
 《我们台湾这些年 I》（未完）  纯好奇，看着作者从小往大介绍，思绪慢慢从我的童年飘到现在，找回不少记忆。不过越往后看，越想借用《南渡北归》中蒋介石的一句话来送给自己和其他心心念互联网自由的人：“汝辈竟无革命精神若此！”
 《奈飞文化手册》  得到APP里面买的，介绍奈飞公司文化的一本书，其实给我的感觉是跟《原则》这本书交相呼应的，书里面介绍的几个价值核心：“我们只招成年人”、“要让每个人都理解公司业务”、“绝对坦诚”、“只有事实才能捍卫观点”要么是有很多共鸣——比如“要让每个人理解公司业务”，我一直觉得公司很多东西该透明要积极去透明，也一直在努力让开发部内部所有的事情都清晰透明；要么就是对我启发比较大——比如“我们只招成年人”。其他章节不是不好，而是因为需要在公司更高层面去运作，所以我的认识相对较少。
旅行 全年两次旅游，一次在宜昌，一次在云南。
宜昌算是散心之旅，我和小崔两个人，游记见摆脱尘世繁杂——宜昌休闲4天游。
云南真的是一场说走就走的旅行，因为今年公司没有组织年度旅游，所以云南游算是全年的大游了，但是其实只是一时冲动陪朋友去云南探亲，结果他的探亲成假，我们旅游去成真了。无游记。
电视剧&amp;amp;纪录片 电影就不说了，跟着小崔看了好多电影。只说下对我印象还比较深刻的电视剧和纪录片。
 《我们这一天》  家庭剧，这部剧让我对未来的家庭充满期待，也很感恩我后来不再是独生子女。</description>
    </item>
    
    <item>
      <title>深度滚动更新工作流程</title>
      <link>https://hualet.org/blog/2018/12/18/%E6%B7%B1%E5%BA%A6%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</link>
      <pubDate>Tue, 18 Dec 2018 11:07:26 +0800</pubDate>
      
      <guid>https://hualet.org/blog/2018/12/18/%E6%B7%B1%E5%BA%A6%E6%BB%9A%E5%8A%A8%E6%9B%B4%E6%96%B0%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B/</guid>
      <description>背景 以前的系统发布模式为平均每3个月一次系统发布——开发周期2个月，测试周期1个月。这虽然保证了每次系统发布的状态都比较稳定，但是仍然避免不了在大量用户在不同场景下产生而发现新 BUG 的局面，而且因为这种发布模式缺少快速更新的机制，导致很多在内部已经得到修复的问题无法及时推送到外网，用户在这段时间内只能忍受一些 BUG 的干扰。所以，我们在 15.6 和 15.7 的时候引入了”发布后一个月“的概念，在这个时间段内，开发主要做问题修复工作，修复的内容可以快速推送到外网，而不用经过繁杂的测试，期望快速解决用户在使用新版本中遇到的问题，这就是深度滚动更新的原型。
15.8开发的过程中，我们又思考了一下这个过程，刚巧我们决定了要尝试”开放和透明“、拥抱社区，所以觉得目前这种把”大教堂“和”集市“两种开发模式揉在一起的方式不是特别明朗，对系统发布者和开发者都是一种负担，所以”从善如流“——从 15.9 开始，deepin 系统的发布开始遵循滚动更新的模式。
滚动更新流程 深度的滚动更新，需要参与系统发布的产品、开发和测试共同合作，所以制定了一套简单的工作流程作为大家协作的基础，从粗到细主要分为了以下几个范围：
1. 系统版本 系统版本的概念跟以前的 15.7、15.8 等没有不同，都会提前指定这 2 - 3 个月的一个工作计划，在阶段性工作完成之后，会有新版本的 ISO 发布。与之前不同的是，新功能不是等系统发布的时候一次性放出，而是在每周开发内容完成、测试通过以后就会放出；另外一个不同是，系统发布不再以完成所有开发内容为前提，而是在系统版本计划的时间点达到以后即发布，未完成的内容放入下个版本工作内容中。
工具使用：
 系统版本规划的内容会展示在官网的“版本规划”中进行展示； 需求文档会邮件通知所有参与系统发布的同事。  2. 里程碑 由于前面所说的新版本不会要求计划内容都完成才发布，所以为了防止工作计划与实际工作产出相差过大，所以将每次系统版本发布做了阶段划分，也就是里程碑。举个例子来说，15.9 开发的阶段会划分为 15.8.1、15.8.2、 15.8.3、 15.8.4 等。
在每次里程碑开始之前，产品需要提前细化里程碑内的需求，在里程碑开始之前还未明确的需求，会被放入下个里程碑中。同样，在这个阶段，测试会根据产品需求编写测试用例。需求和测试用例都会经过一次评审。每个里程碑到达预定时间点之后，未完成的工作内容会按照优先级放入下个里程碑或者延后处理、放到其他里程碑中。
工具使用：
 里程碑使用 github issues 中的 Milestone 工具来进行管理； 细化的需求文档以及需求变更会邮件通知所有参与系统发布的同事。  3. 工作周 每个里程碑由两个工作周组成。在每个工作周内，开发需要完成计划中的开发内容和上个工作周测试问题的修复工作，在每周结束的时候，开发对稳定的项目打 tag，并提交到 crp 平台进行打包、提供 changelog 供产品和测试在下个工作周进行验收。同样，在每个工作周内，产品和测试需要完成对上周开发内容的验收工作，保证在周三前完成功能验收、功能测试和 BUG 修复，周四时发布更新。
工具使用：
 系统各个组件包版本控制、changlog 使用 crp 进行管理； 每周更新内容在 internal-discussion 中建相应里程碑发布任务的 issue 进行说明； 社区官网提供每次更新的更新注记。  目标 目前对滚动更新的期望主要有以下几点：</description>
    </item>
    
    <item>
      <title>修理 FreeRDP</title>
      <link>https://hualet.org/blog/2018/12/16/%E4%BF%AE%E7%90%86-freerdp/</link>
      <pubDate>Sun, 16 Dec 2018 14:41:44 +0800</pubDate>
      
      <guid>https://hualet.org/blog/2018/12/16/%E4%BF%AE%E7%90%86-freerdp/</guid>
      <description>起因 头段时间入了一个大坑儿，大概被坑了有一个月之久，出来之后同事还不忘嘲讽一番：”这么个事情就搞了一个月，看吧，你果然是老了“。听了这句话，心里真是百般滋味，但转念一想，”我年轻的时候做事好像也不怎么快“，顿时也就释怀了 :)
这个坑就是”给 FreeRDP 的 RAIL 模式添加托盘支持“，当然，跟所有的需求一样，这么具有总结性而又直指根源的需求描述，绝对不是它最原始的模样——我刚接到这个坑的时候，它是这样的：FreeRDP 的 RAIL 模式下，应用的托盘在我们 DDE 下不显示。请注意这里说得是不显示，而不是后来发现的压根儿没有支持！
FreeRDP 说到这，可能有读者还不了解 FreeRDP 和 RAIL，所以先简单介绍一下。
RDP 其实是一个协议名称，全称 Remote Desktop Protocol（远程桌面协议），是微软公司开发的一套用于远程桌面展示和操作的协议，FreeRDP 就是它在开源世界的实现咯。而 RAIL 的全称是 Remote Application Integrated Locally （远程应用本地集成），其实就是非常类似大家熟悉的虚拟机的”无缝模式“，通过将应用的显示跟本地环境相融合，让用户完全感受不到这个应用其实不在本机运行——就是这么一种技术。
问题也就出在这，我当时第一反应是这么老的技术实现肯定比较完整了，托盘没有显示出来应该是跟 DDE 的兼容性有点小问题，稍微修一下就完了，三下五除二的事情，所以满口答应了下来……
经过 既然答应了，硬着头皮也要顶下去的。何况调 BUG 这种事情——不管是不是我们自己的问题——在深度都是家常便饭。慢慢地，调各种项目的 BUG 竟然成了我的一种乐趣——每次开始接手一个新的项目的时候，我都把自己当成了福尔摩斯或者胡八一，或者也可以是其他全世界最聪明的那类人 😜，在通过代码找寻问题线索的过程中，慢慢成为这个项目世界中的主宰，解开真相……
额……不好意思，白日梦又发作了一会儿。总之，这次也不例外，而且刚好这次在调问题的过程中有记录几个关键环节，所以打算把中间的过程写成日记性质的记录，看看能不能有更好的阅读效果：
2018-11-14 从”沈老板“那收到需求，说 FreeRDP 在我们系统上有问题，应用的托盘显示不出来，QQ之类的程序关闭了窗口以后就没办法显示出来了，无法使用。这丫的又拿刘老大来压我……呵呵，想削他。不过看在他快要当爸爸的份上，还是算了。问了下时间要求，大概需要两周左右有初步的结果。不过我自己最近没有什么时间，先把锅丢给了印象中还比较熟悉网络协议的 @Blumia 同学。
2018-11-15 从 @Blumia 那收到反馈，可能 FreeRDP 没有实现托盘图标这部分的功能，我怕他一个人搞不定，简单翻了翻 FreeRDP 的项目 wiki 和 RDP 的一些介绍，给了他，让他先帮忙找一下需要补充实现部分的代码结构。
2018-11-16 没时间处理。
@Blumia 搭了测试环境。
中间几天两个人都没有时间处理 FreeRDP 的事情。
2018-11-22 留了少部分时间，看了 FreeRDP 的代码，大概找到了托盘图标相关处理应该在的位置。</description>
    </item>
    
    <item>
      <title>15.8研发心得</title>
      <link>https://hualet.org/blog/2018/11/21/15.8%E7%A0%94%E5%8F%91%E5%BF%83%E5%BE%97/</link>
      <pubDate>Wed, 21 Nov 2018 09:07:31 +0800</pubDate>
      
      <guid>https://hualet.org/blog/2018/11/21/15.8%E7%A0%94%E5%8F%91%E5%BF%83%E5%BE%97/</guid>
      <description>不早也不晚，2018年11月15日 deepin 15.8 如期发布。这虽然是个好消息，但是没有了延期的梗，我竟然不知道这篇研发心得应该如何开头……😓
开头这件事情总是很难，因为要做到一些以前没有做到的事情，就要求能将自己的水平提高哪怕那么一点点；同时，开头也不宜于高调，高调的开头太容易造成虎头蛇尾以致不能坚持的局面。在我的价值观里，与其浪费时间和精力在不能坚持的事情上，还不如什么都不做。所以很多事情我都不愿意开头，就像写这篇研发心得一样。
不过，幸运的是我们对发布系统这件事情倒是充满着热情，以至于我们能在每一次系统发布的“轮回”里，都无所畏惧地开头并且坚持如一。比如 15.4 的毛玻璃效果、15.5 的高分屏、15.6 的应用深色主题、15.7的性能优化等等等等……当然，这次的主角 15.8 也不输从前。
新特性介绍 15.8 中新的变动着实不少，但是从一个研发的角度来看，我觉得最重要的变化应该是组织系统开发和发布的人发生了变化。之所以说这个比较重要，是因为 deepin 的前辈们把接力棒交到我这里，我终于可以把它顺利地转交到合适的人手中了，这句话的言外之意是什么呢？就是大家以后如果遇到什么 bug，进门左转找 @zccrs 😂。
说明了以上信息，就可放心地介绍这次的新功能了。不过说实话，这次的新功能都相当直观，用不着我费什么口舌，再加上本次研发心得的重点不在此，所以大部分的新功能请看 系统发布新闻，这里只说两个我最喜欢的点吧。
第一个要说的，是15.8 的新功能里面最让人惊喜的 Dock时尚模式 的托盘插件 的设计调整：
为什么呢？这主要是因为以我的聪明才智，都一直认为时尚模式的托盘是一个无解的问题：系统托盘占用大量空间，应用托盘使用不方便……除非引入类似 macOS 的 topbar （估计很多人也是这么想的，所以都默默地在商店里面安装了 deepin-topbar吧）。事实上，当时我们讨论解决方案的时候也是差不多一样的状态，每个人都欲言又止，显然是还没说出口的方案就被自己推翻了，然而就在这个时候，设计师默默地上了一副设计图，把所有的应用托盘也放大成了与应用图标无异的大小。
我：！？！？！？（黑人脸
我刚要扔臭鸡蛋，设计师咔嚓又上传了一张图，仿佛在说 “蛋下留人～” 而转机就这样发生了，我看到设计图，就如大家在15.8看到的Dock时尚模式一样，托盘问题竟然被 almost 完美地解决了——在最后的关键时刻设计师保住了自己的颜面。
怎么说呢，这基本上是我在深度继看到一个开发同事用钥匙给电脑开机感到由衷地佩服以来，再一次罕见地（尤其是被设计师？😈）觉得世界观被刷新的一次体验了。
另外一个要提的是一个很小的点，不过现在想起来都会有一种吃了广告中的德芙的感觉——丝滑。是什么呢？如果你现在使用 deepin 浏览这篇文章，应该能看到我特地在文章开头、上一段和中间甩锅那一段，几乎到处都贴了 emoji 表情：
 能正常显示，而不是豆腐块！ 关键是它们是彩色的！！！  整篇文章不再有黑乎乎的表情——这简直是使用Linux写技术博客的 Blogger 的福音啊。如果你也想在文字编辑的时候输入开爱的 emoji 表情，可以打开 https://getemoji.com/ ，只需 copy&amp;amp;paste，瞬间让你拥有进入 21 世纪互联网的赶脚。
至于这个新特性为什么没有写到更新注记里面，是低调，是彩蛋，还是忘了写？咳咳，有点赶时间，继续往下写了 🙄🙄🙄 。
开放和透明 上面说了发系统的接力棒已经成功交（shuai）接（guo）给别人了，那我去干啥了呢？总得做点啥吧，要不被开了就不好玩儿了嘛😱。
我这段时间做得其实就是开放和透明。
在中国说起开源，应该没有人不知道深度作为“东半球最大的开源软件公司”的名头，如果有人不知道，那也让我们先姑且这么认为着 😜， 深度从出生的那一刻起就一直在开源——深度出品的软件产品中95%以上都是开源的，但是直到最近我才老有一种感觉就是深度一直在“开源”，但是并没有在“做开源”。
深度是很长于做产品的，每个产品都可以做得既小巧玲珑，又戳中用户痛点，所以积累了不少海内外用户。这些用户使用着我们的系统，时不时灵感来了还会提出一些宝贵的意见和建议，这本是极好的。但是作为开发者的我发现，其实这批用户里面有不少同行，他们也想为深度的开源事业做出自己的贡献，天天问我：How to contribute。我脑子飞速旋转，“这个功能貌似他可以加一下？不对，这个功能需要知道很多故事背景，说来话长……还是算了”，“那个bug他好像可以修一下，但是好像也不能按照常规的方式去修复……一两句话也说不清楚”。思来想去，最后只能以“你可以帮我们测试，测试也是一种贡献呀”、“你会德语呀，这么厉害，要不要帮我们加点翻译” 等等的回复搪塞过去，说完这些内疚到简直想出去哭一场。更有甚者，有些开发者克服了重重困难，终于提交了 CL （可以理解为补丁）想要一些功能，内部讨论半天给出一个决定和回复，对方回复，内部再讨论半天给一个回复……效率极低，还容易导致各种误解。更可惜的是，以后甚至还会有同样热心的开发者提交类似的补丁，然后重复前面的过程，及其浪费社会生产力。</description>
    </item>
    
    <item>
      <title>通过 Unix Domain Socket 传递文件描述符</title>
      <link>https://hualet.org/blog/2018/10/28/%E9%80%9A%E8%BF%87-unix-domain-socket-%E4%BC%A0%E9%80%92%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/</link>
      <pubDate>Sun, 28 Oct 2018 21:08:45 +0800</pubDate>
      
      <guid>https://hualet.org/blog/2018/10/28/%E9%80%9A%E8%BF%87-unix-domain-socket-%E4%BC%A0%E9%80%92%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6/</guid>
      <description>Unix Domain Socket 是 Unix 系统下重要的本地进程间通信（IPC）机制之一，在 DDE、GNOME、KDE 等 Linux 桌面环境中常见的进程间通信方式 DBus 有一种实现方式就是基于 Unix Domain Socket 做的。虽然一直知道它的大名，也一直知道 Unix Domain Socket 可以用来传递文件描述符，但是碍于以前经验和眼界不足，加上没有深入去了解，完全不知道能传递文件描述符是多么强大的能力和必要性。
首先，我想着文件描述符不就是一个数字么，哪个 IPC 不能传递数字呢？完全没有思考到文件描述符是只在进程范围内有效，同样一个文件描述符放在不同的进程完全就不是一回事儿。这时候你肯定想，既然传递文件描述符这么麻烦，为啥非要传递文件描述符呢，使用文件名不也是一样的么？那么恭喜你，你也有更我一样在践行陶渊明老前辈看事物“不求甚解”的作风。传递文件描述符还是有它的必要性的，一方面，文件描述符代表的不只是一个文件，它还包含了文件打开的状态，比如 seek 的位置等，有点进程之于可执行程序的意思，拿到文件描述符也就拿到了这些动态的信息；另一方面，文件描述符不只对应于本地文件，它为了一众可读写对象提供了统一的读写接口，包含什么呢？本地文件、（匿名）管道、标准输入输出、甚至于 Socket 本身等……可以让你完全不关心文件描述符背后的实现是什么而方便实现自己的逻辑代码。
想通了以上道理，又有了以前似曾相识的感慨“古人诚不欺我”——前人留下的东西，必然有一定的合理性。这也是为什么我比较排斥看见一个软件不满意就立即重新造，尤其是能流传很广或者流程时间很长的软件，里面很多看起来不必要的东西，可能有其存在的合理性，最好的做法是尝试去改进，改进的过程了解其历史、学习其精髓，等自己胸有成竹的时候再下手重造不迟。额，跑题了……
回到正题，之所以前段时间突然研究了一下 Socket 传递文件描述符的东西，是遇到这样一个需求：一个进程将自己的标准输入、标准输出和标准错误输出映射到另外一个进程相应的位置。带着对 Unix Domain Socket 的朦胧认识，写了一个简单的实现原型：
// outlet.c #include &amp;lt;sys/socket.h&amp;gt; #include &amp;lt;sys/un.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;stdio.h&amp;gt; #include &amp;lt;errno.h&amp;gt; #include &amp;lt;unistd.h&amp;gt; #define SOCKET_NAME &amp;quot;/tmp/connection-uds-fd&amp;quot; int make_connection() { int fd; int connection_fd; int result; struct sockaddr_un sun; fd = socket(PF_UNIX, SOCK_STREAM, 0); sun.sun_family = AF_UNIX; strncpy(sun.</description>
    </item>
    
    <item>
      <title>给 Doxygen 生成的文档中 Qt 的引用添加链接</title>
      <link>https://hualet.org/blog/2018/09/28/%E7%BB%99-doxygen-%E7%94%9F%E6%88%90%E7%9A%84%E6%96%87%E6%A1%A3%E4%B8%AD-qt-%E7%9A%84%E5%BC%95%E7%94%A8%E6%B7%BB%E5%8A%A0%E9%93%BE%E6%8E%A5/</link>
      <pubDate>Fri, 28 Sep 2018 16:42:40 +0800</pubDate>
      
      <guid>https://hualet.org/blog/2018/09/28/%E7%BB%99-doxygen-%E7%94%9F%E6%88%90%E7%9A%84%E6%96%87%E6%A1%A3%E4%B8%AD-qt-%E7%9A%84%E5%BC%95%E7%94%A8%E6%B7%BB%E5%8A%A0%E9%93%BE%E6%8E%A5/</guid>
      <description>额……这个标题怎么改读着都不怎么顺口，不过不用在意这些细节，问题不大 :)
上篇文章提到了 如何给DTK添加文档 ，给同事讲的时候有同事提出来最好能自动给对 Qt 的引用加上链接，我当时拍胸脯说文档里面 Qt 的类和方法随便引用，到时候一定让生成的文档可以链接到 Qt 的文档上。其实，到啥时候我也说不准……所以，还是研究了一下，翻了半天的 Stack Overflow 和 其他一些资料才搞清楚要怎么做到，这里记录一下。
如何在文档中添加外部文档的链接呢？官方文档 说得其实挺简单的： TAGFILES ！最开始没有仔细看文档，理解歪了，以为 tags 文件是一个文档压缩包，添加到 TAGFILES 这项后面生成文档的时候自动下载，然后自动根据索引添加引用链接到文档中。所以，根据 doxygen generated documentation with auto-generated links to qt project 这篇文章，Doxyfile 配置文件写了：
TAGFILES = qtcore.tags=http://doc.qt.io/qt-5/ \ qtgui.tags=http://doc.qt.io/qt-5/ \ qtwidgets.tags=http://doc.qt.io/qt-5/ \ qtxml.tags=http://doc.qt.io/qt-5/ \ qtnetwork.tags=http://doc.qt.io/qt-5/  生成文档，怎么都不生效…… WTF ?!
继续 Google ，发现一个提交， 里面的
for i in core svg xmlpatterns; do curl -fsSLO &amp;quot;https://doc.qt.io/qt-5/qt$i.tags&amp;quot;; done;  引起了我的注意，恍然大悟：
原来这个 tags 文件就是索引文件，需要预先下载下来，之所以有 = 加上一个网址，是因为 tags 中只有类名到文档名的映射，并没有规定使用某种协议以及host。</description>
    </item>
    
    <item>
      <title>如何给 DTK 添加文档</title>
      <link>https://hualet.org/blog/2018/09/26/%E5%A6%82%E4%BD%95%E7%BB%99-dtk-%E6%B7%BB%E5%8A%A0%E6%96%87%E6%A1%A3/</link>
      <pubDate>Wed, 26 Sep 2018 17:10:14 +0800</pubDate>
      
      <guid>https://hualet.org/blog/2018/09/26/%E5%A6%82%E4%BD%95%E7%BB%99-dtk-%E6%B7%BB%E5%8A%A0%E6%96%87%E6%A1%A3/</guid>
      <description>背景 经过几年的摸爬滚打，DTK 作为构建 deepin 全家桶的基石，一直被说的主要有两个毛病：
 内部人员觉得它不够稳； 外部人员觉得它无从下手；  第一个问题主要原因是 DTK 在最开始的时候缺失的东西太多，各种剧烈的变化同时进行，但是又没有比较好的版本控制和接口管理，所以经常是这个应用要用新版本，新版本删除了一个废弃的接口，用了旧接口的应用就崩了。由于最近 DTK 的变化日趋平稳，以及有了基本的版本控制，第一个问题渐渐淡出了人们的视野。
第二个问题外部人员无从下手的原因是 DTK 在开发过程中并没有留下接口文档，所以目前想使用 DTK，内部靠得是口口相传，外部靠的是阅读源码，完全的石器时代……甚至连社区的小伙伴都看不下去了，自己做了一个《Deepin开发指南》 。
是时候给DTK添加一下文档了！
工具选择 其实， DTK 之前是有写文档的，但是写得并不多，主要问题就是英文文档不好写。我也尝试写过，每个类、每个函数都只能憋出一句英文，这种文档跟没有是差不多的。所以，这里需要做一个艰难的决定：文档用中文来写，英文靠爱好者来翻译。
用什么文档工具呢？ DTK 是基于 Qt 之上的开发库，最自然的想法是使用 QDoc，但是据使用 QDoc 搭建了 dde-file-manager 的 Github Pages 的 @BLumia 同学说 QDoc 对国际化的支持不是特别好，我们按道理是要支持中英双语文档的，遂放弃。除了 QDoc 以外，文档生成工具就是 Doxygen、还有一个KDE 项目自己的文档工具 KApiDox ，它们三者之间是什么关系呢？Doxygen 从 QDoc 上 fork 出来的，KApiDox 是基于 Doxygen 的封装……我没有怎么看 KApiDox ，所以就选择了 Doxygen 。
如何写 下面就是规则部分了。
1. 文档注释位置 为了保持头文件的清爽和干净，所有文档注释都要写在源文件中。
2. 多语言 按照 Doxygen 多语言处理的方式，需要在中文文档前添加 \~chinese 命令，在英文文档前添加 \~english 命令，这样设置 Doxyfile 中 OUTPUT_LANGUAGE=Chinese之后，就只会包含中文文档，而不会夹杂英文了，如：</description>
    </item>
    
    <item>
      <title>关于 deepin-code-release 的一点新的思考</title>
      <link>https://hualet.org/blog/2018/09/17/%E5%85%B3%E4%BA%8E-deepin-code-release-%E7%9A%84%E4%B8%80%E7%82%B9%E6%96%B0%E7%9A%84%E6%80%9D%E8%80%83/</link>
      <pubDate>Mon, 17 Sep 2018 15:23:47 +0800</pubDate>
      
      <guid>https://hualet.org/blog/2018/09/17/%E5%85%B3%E4%BA%8E-deepin-code-release-%E7%9A%84%E4%B8%80%E7%82%B9%E6%96%B0%E7%9A%84%E6%80%9D%E8%80%83/</guid>
      <description>为什么要做 deepin-code-release 呢？其实我们在 deepin-code-release 的 README.md 中写得挺详细了：
 从deepin项目启动开始，伴随着越来越多的deepin子项目产生，不同开源/商业定制版本的分割加剧，项目间的版本依赖问题、上游项目的patch丢失问题和系统环境无法恢复问题越来越严重，我们迫切需要一个统一的系统来帮助我们记录不同版本的ISO/软件仓库的状态，做各个子项目版本的版本控制和patch的版本控制，以达到快速恢复开发/系统环境，进而使针对不同系统版本的开发更加高效。
deepin release系统就是这样一个辅助系统，它的目标在于将它的每一个状态都对应到我们所有发布的ISO/软件仓库状态、每一个针对ISO/软件仓库的改动都能反映到这个仓库的改动上。
 简而言之，deepin-code-release 是版本的版本控制管理工具，用来管理 deepin 众多“轮子”项目的版本号的，每次系统发布都需要进行一次记录，方便以后开发修问题的时候能找到当时的代码进行bug修复。
为了确保记录的准确，它的想法是这样的，每次（系统）发布前，深度的程序员各自检查一下自己负责的项目，如果需要跟随系统进行发布，就提交 CL 到 deepin-code-release 项目，这个 CL 会自动触发项目在对应仓库的打包，并且将打包结果反馈到 CL 的 Code Review 评分上，+1 分的就进行合并，反之闭门思过解决问题后再次提交，直到成功合并。
问题 以上需求还是听简单明确的，但是在目前的实现上却有一个问题：使用了 git-submodule 进行子项目的管理，再加上其他几个没有考虑的情况，这导致了好多小问题，以至于推行到现在还是阻碍重重：
1. 使用起来比较麻烦 deepin 的项目都是放在 gerrit 上的，它并没有一个统一的 git 用户（类似git@github.com中的git），所以同一个项目在不同开发人员的机器上的项目地址是不一样的，当成 submodule 放到 deepin-code-release 这个项目中以后，必须驱动项目地址中的用户名部分，再在 ~/.config/ssh 中添加一些额外的配置（参见 README.md ）。
2. submodule 用起来比较别扭 最直接、也是抱怨最多的一点，是大家平常使用 git submodule 系列的命令并不多，所以对操作 git submodule 有不太习惯，而且就算是我比较熟练了，也总觉得 git submodule update 这个有点反直觉，感觉上应该是类似 git pull --recurse-submodules 的功能，但是实际上并不是这样。以至于很多人一不小心，把别个辛辛苦苦提交的更新又给退回去了。
3. 多了一个额外的仓库 原本的打算是每个开发都只需要克隆一个 deepin-code-release 项目，然后在其中 init 自己负责的项目并进行提交，需要关注多个项目的就按需 init 多个项目即可，但是实际推行的过程中还是发现大家并不是特别关注自己项目外的项目，deepin-code-release 里面就一个自己的项目初始化了，而且用着还挺别扭，还不如自己单独克隆一份，结果就每个开发上面既有一个自己项目的仓库，还要有一个包含了自己项目仓库的 deepin-code-release 项目，也是抱怨声颇多。</description>
    </item>
    
    <item>
      <title>15.7 研发心得——最好版本的台前幕后</title>
      <link>https://hualet.org/blog/2018/09/02/15.7-%E7%A0%94%E5%8F%91%E5%BF%83%E5%BE%97%E6%9C%80%E5%A5%BD%E7%89%88%E6%9C%AC%E7%9A%84%E5%8F%B0%E5%89%8D%E5%B9%95%E5%90%8E/</link>
      <pubDate>Sun, 02 Sep 2018 10:27:00 +0800</pubDate>
      
      <guid>https://hualet.org/blog/2018/09/02/15.7-%E7%A0%94%E5%8F%91%E5%BF%83%E5%BE%97%E6%9C%80%E5%A5%BD%E7%89%88%E6%9C%AC%E7%9A%84%E5%8F%B0%E5%89%8D%E5%B9%95%E5%90%8E/</guid>
      <description> 15.7 终于如期地发布了……好吧，也就晚了2个工作日……毕竟这么好的版本，多等两天也可以的，对吧。需要多解释一句的是，我们之所以也没有按照往常的套路——拖到周五发，是因为周五刚好是情人节，毕竟程序员找个女朋友不容易，所以就拖了两天……这应该是个好借口吧 :P
发完系统第一件事情当然就是写《研发心得》咯，不知道从什么时候开始，《研发心得》成了发布标配，上午发系统，晚上就要《研发心得》，我只能微笑着说……嗯，挺好的！不过虽说是研发心得，但是别人看了我的心得以后都说像软文。我的想法是这样的：像软文就像软文嘛，让各位支持deepin的朋友看得舒舒服服的同时还能了解新功能，多好！
不过这次我准备换个风格，重点是真实。所以，这次的心得我准备说说 15.7 这个版本的台前幕后。
台前&amp;amp;幕后 “这是我用过的最好的deepin版本”。
我预测应该有很多用户会跟我有同样的想法，毕竟，对于发了这么多版本的我来说，15.7 是第一个版本让我有重新完整安装一次这样冲动的版本。三年多以来，每逢系统发布前，我都会挑一个良辰吉日加上一个好时间，这个时间其实主要取决于版本发布的延期情况而定，隆重地安装一下即将发布的新版本的ISO，说是为了测试一下其实是骗人的，毕竟我也测试不出什么bug来……主要是装一下心里面爽啊，你们要明天才能下载，我今天就用上了，呵呵呵……
虽说每次的ISO我都安装过，但是我从来没有舍得把我现在在用的系统格式化掉重新安装，因为这个老家伙从deepin切换仓库到Debian我重新安装了一次系统开始就一直陪伴着我，没有必要的话，我是想一直让它继续往上升级的。直到这次15.7发布，我感觉它又是一次值得纪念的发布才想着来一次完整重装，不过冲动归冲动，我还是按捺住了心中那团火——还是没有重新安装，因为思来想去，升级上来的也是一样的嘛 :)
这次升级可以分为两大部分，一部分是DDE的优化，另一部分是仓库同步Debian上游。从一个用户的角度出发，我觉得吸引我的地方，或者说值得用户期待的地方主要有这么几个：
更快的启动速度 这个主要得益于“林姐”亲自操刀的文件预热技术warm-sched，它主要的原理是这样的，大家知道操作系统在启动的过程中，会进行大量的IO操作，这个在CPU性能不是问题的平台上就是启动慢的罪魁祸首了，大家还知道Linux内核其实本身是有文件缓存机制的，被缓存的文件访问会非常非常快，所以如果我们在系统加载的适当时候能进行一定的预热，那么系统加载的时间当然就会大大缩短了。
不过这个会导致的一个问题就是，用户登录的速度变得飞快（从原来的10s+变成3s），但是系统好像在deepin水波纹的时间似乎更长了，其实不用”似乎“，真的会这样，文件预热技术不是神话，它没办法吃掉那部分加载文件的时间，它能做到的只是在合适的时间点预热下一个阶段需要的文件。
”这不是拆东墙补西墙么？“你可能会这么问，但是我要告诉你还真不是，如果没有预热，系统加载文件的过程是”乱序“的，这里的乱序是指文件存放不一定是顺序存放在磁道上的，乱序的文件访问会导致磁盘访问的过程中转来转去的，效率低下；相反，warm-sched不仅只是对文件预热，加载的过程可以保证磁盘的顺序访问，文件多了的话，这部分优化还是比较可观的……
我记得以前有位同事总是喜欢开玩笑说”苍蝇也是肉啊“，当时在饭桌上没少让人倒胃口，但是这句话用在性能优化、以及上面这个例子上算是再合适不过了。
更少的资源占用 首先是电量，如果你是笔记本的话，应该能感受到笔记本续航的提升，deepin测试人员实测的数据是以前3小时续航能力的笔记本，待机会多出30分钟+的时间，也就是提升差不多有17%，跟使用powerstat这个工具测试的效果基本相差不大。那是不是原来待机4个小时的笔记本，也只会多出30分钟的续航时间呢？并不是的，因为这是一个功耗比例上的变化，这次优化以后理论上可以增加的待机时间就是 原来的待机时间x17% 了，如果你的电池健康程度够的话，应该能有更大的优化效果。
不过，这些都是在使用电池的情况下的数据，因为默认情况下deepin系统只有在拔掉电源的情况下才会自动进入节能模式，如果你想在连接电源的情况下也开启节能模式，我是说假如你真这么环保的话，你可以在控制中心的电源模块手动打开节能模式；相反，如果你像我一样不在乎耗电，只追求卓越的性能，你也可以随时把节能模式关掉，大丈夫就是这么帅，不怕编译的时候机器烫手；总之，由着你的性子来！
另外一个能明显感受到的变化是开机内存的减少，这里所说的开机内存是指在没有任何开机启动项的情况下，DDE达到稳定状态的一个内存值，由原来的 1.1G 占用降低到 830M 左右，在使用独显的情况下，内存占用会更低，简直令人发指！好处是什么呢？更低的内存占用意味着DDE变得更加轻量，应用程序可以占用更多的系统资源，例如你是chrome这个内存占用大户的用户，15.7 可以让你在系统不变卡的情况下多开十来个标签页呢，是不是很开心？
不过做这些优化的过程中最让我感到意外的是DDE对电量消耗的“助攻”竟然没有大家预想的那么多，进程抽风性地CPU占用高、间歇性地进程状态切换等居然连硬件功耗的零头都占不到，不过该改的地方一个都不少，所以，DDE 的CPU占用高的问题在15.7中也可以不用再见了。
更新的软件和驱动 这个就不用多说了，搭载了Debian上游最新的一波升级，你想要的“更新的软件”、“更新的驱动”统统都给你，就是这么大方！而且，这次你收到的不仅仅是一次更新带来的快感，更是deepin更新会变得更加快、准、狠的承诺。在15.7的需求中我们争论了好多次，一方说已经有太多用户吐槽我们软件不够新、基础库不够新，用户需要新的软件；另一方说更新太快容易导致用户环境不稳定，我们毕竟是一个面向普通用户的发行版；争论不休，都可以开一个深度辩论赛了……最后终于达成一致，我们希望能更快速的将软件更新推送给用户，不再一次性积累大批量的更新，同时保证一定的节奏，确保快速更新的同时不会挂挂挂。
另外，值得一提的是论坛用户和老板不停的要求、催促和威逼利诱下，我们终于——终于把PRIME方案引入到了深度显卡驱动管理工具中，现在如果你是双显卡（N+i）用户，你只要小手一点，就可以方便地在几个预设方案中轻松切换了……嗯，不辛苦，用户和老板高兴就好 :)
一点感悟 上面说了这么一大堆，其实当时为了准备这些优化的内容的时候，心里面还是比较慌的，因为系统优化这事儿做起来远没有听起来那么爽，尤其是在没有既定方法的情况下要定一个优化目标出来，还是相当无助的，而且一旦你陷入 盲目—烦躁—焦虑 的怪圈中，就很难再痛快地出来，这就是这次15.7所面临的第一个挣扎。
我跟几个程序员都交流过，程序员大多都有比较强的焦虑感，再加上程序员多有洁癖，动不动这不清真那不科学，更容易掉进上面这个怪圈，在这个怪圈里面，你要么有一天实在承受不了了，咔嚓——破罐子破摔，从此成为浩瀚宇宙中的一粒尘埃；要么有一天你想通了：“还想个毛，就是干”，然后挑一件事后跟别人扯淡都羞于提起的小事，慢悠悠地开始做，做完了你会发现你的心理负担变轻了不少，然后再挑一件小事，接着干……越干目标越近，焦虑感也越来越少……最终，完成发版大业。
所以，当时我们不知道到底优化目标定成什么样子，那就捡最笨的方法，跟其他几个操作系统：Ubuntu、Win7、Win10做一个横向对比，看看其他几家的情况，至少做到在单一侧面都不是最差的吧？（做到任一侧面都是最好的，就留作下次优化的目标吧，毕竟大家都等着咱们发版呢。）定完了就朝着目标开始研究怎么使用优化的工具：perf、valgrind、heaptrack、google-perftools等，大家都不怎么有经验？那就学一个培训一个，各自有任务去练习……等优化的patch都集成完了，对比下优化目标，不够或者还不满意就再来……所有15.7可见的优化都是这么一点点的“苍蝇肉”拼出来的。
刚好最近在Twitter上看到的一段话，可以把我上面想说的非常明白的表达了出来，把这段“心得”分享给大家：
 真的，诸位，有什么难事千万别耗着，别等着，那只会让人在无尽的焦虑中煎熬，你就先大吼一句：“去你妈的。”然后两眼血丝地去推进，去做事，做着做着就有出路了。
 </description>
    </item>
    
    <item>
      <title>致王勇</title>
      <link>https://hualet.org/blog/2018/06/18/%E8%87%B4%E7%8E%8B%E5%8B%87/</link>
      <pubDate>Mon, 18 Jun 2018 20:25:10 +0800</pubDate>
      
      <guid>https://hualet.org/blog/2018/06/18/%E8%87%B4%E7%8E%8B%E5%8B%87/</guid>
      <description>以下内容是我在知乎对“如何看待Deepin操作系统创始人王勇离职”的回答。
这个月，从王勇改微博后缀，到删除deepin字样相关的代码，再到一则朋友圈，最后论坛的一篇《感谢亲爱的你们，大家继续加油》，有好几个朋友过来问、或者代朋友问王勇的情况，我虽然已经知道他的打算，但是不管朋友远近我都是说他在家休息，因为我知道他离开的消息有多大的影响。现在大家都知道了，也都震惊了，有人觉得伤感、失落，包括我自己都一样，这没什么，但是很多无良的媒体大肆渲染，最后以讹传讹，我甚至感觉我明天就不用去上班了……
压抑了好久，有必要在这里说说。
王勇离开深度，我觉得对我最大的影响是 少了一个导师，没有了精神寄托。
跟很多deepin的粉丝一样，我还在上大学的时候就知道了deepin，随之就对deepin和ManateeLazycat（王勇的网名）产生了巨大的喜爱，成了王勇的脑残粉；幸运的是我居然凭着自学（当然也得感谢当时猴哥和xiangzhai在网上对我的指导），拿到了去深度工作的机会。而我刚进深度的第一个目标就是“王勇，我要在技术上超越你”，被王勇知道后以至于到现在还被他拿出来刺激我 :O
深度当时的技术氛围非常浓厚，因为一个屋子，清一色的程序猿。所以在深度的第一年里，是我技术成长接触面最广的一年，学了很多语言，接触了很多技术，对我影响最大的可能就是跟着王勇和猴哥学了Emacs，另外也自学了Elisp和Common Lisp，虽然当时心高气傲搞了一个hualet-emacs，实际上用王勇的话说“就是对着deepin-emacs抄嘛 :P”，事实上也确实如此，那时候也是第一次看到王勇在UI细节打磨上执着，他把emacs的每个插件都折腾成自己的风格，所有插件放在一起你都不觉得他们是分开的，自成一套体系，对我影响很大。
后来的一年多时间，是我在深度的沉寂期。默默无闻，但是我看到了王勇做的一些事情，其中就包括跟其他社区的人吵架，或者叫“互喷”吧。当时有点不能理解，社区都好好相处，不是挺好么，还容易积聚力量，后来慢慢懂了。前段时间看《走向共和》和《曾国藩的正面与侧面》，我觉得王勇很像晚清那些想叫醒中国人的斗士、英雄，看到开源社区很多浮在空中的“所谓的大牛”，说的话都对，却很少或者说从来不做实事，而愤怒地发出怒吼。
“有了求实一念，人才会从道德制高点上下来，脚踏实地，不激不随。”我觉得王勇能成为我心目中的领袖，是他很早就知道“求实”，而不是站在道德的制高点上喷这个、吹那个。
15年的时候，我迎来了自己在深度的机会：掌管桌面组和系统发布。但实际上当时我申请了这个职位以后没过两周我就后悔了，深度的用户都知道，15版本是近年来最大的一次版本变迁，首先是仓库从ubuntu切换到了debian；另外是桌面环境全换Qt重写。这对我来说不仅是巨大的工作量，关键是我当时还主要是做应用，压根儿不知道这个桌面是怎么一步一步被做出来的，还要面临的一个问题是为了赶商业机会，我们的重写必须在那3-6个月完成，那时候真的是异常痛苦。
也就是这个时候，我和王勇的关系才从以前一种盲目崇拜与被崇拜，变成了学生和导师的关系。记得非常清楚，无数个加班的夜晚，我跟兄弟们加完班以后，还得找王勇“倒垃圾”，这个事情有多难、有多坚持不下去、这方面有问题怎么办、那方面又问题怎么办……有时候王勇也不见得有什么好的办法，但是有一个人一直在支撑你走下去的感觉，会产生奇迹。这种经历一生也不会有太多。
那半年是我蜕变的半年，王勇在其中起了太多的作用。
所以要说王勇身上背负的不仅仅是自己的压力，还要背负兄弟姐妹们身上的压力，这个压力我自忖是完全承受不来的。这也是为什么当时猜出来王勇要离职的时候，我对他说“从公司员工的身份上我对你这个决定是接受不了的，但是从朋友的角度我觉得你做这个决定我很佩服”。他确实承受了太多事情，如果都这么决定了，我们能做的就是尽量不要给他压力。
王勇临离开之前做的最后一些事情，就是研发各个团队的负责人挨个谈了一遍，跟我说的内容很少涉及自己怎么样，更多的是帮我捋清方向。
就这样。
至于说深度会不会因此倒闭了，或者说deepin项目会不会凉了，我觉得至少短时间内不会。
一方面，王勇作为武汉研发总部的负责人，长期以来从来也没有忘记去培养人，培训和言传身教，影响了一部分有想法的同事，虽说我们现在没有能力像他一样作为个人去领导一方，但是目前在做的事情是可以承担起来的；另一方面，就像 张成前辈 的回答里面说的一样，深度前期能在完全没有盈利目标的情况下开始做，到现在依然坚持在为社区做贡献，王勇的热情是一部分、刘总（deepin）对社区的看重是另外一部分。现在王勇出走了，但是我没有看到刘总说社区就此打住、不再做了，实际上公司上下稍微有点Linux背景的人都没有质疑过社区这一条方向。所以deepin项目不会就此凉了，相反我们可能会在做国产化的同时去探索更多的面向社区和普通消费者的方向。
最后，致勇哥一声深深的谢谢！</description>
    </item>
    
    <item>
      <title>使用 Perf 优化程序性能</title>
      <link>https://hualet.org/blog/2018/06/16/%E4%BD%BF%E7%94%A8-perf-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/</link>
      <pubDate>Sat, 16 Jun 2018 20:54:44 +0800</pubDate>
      
      <guid>https://hualet.org/blog/2018/06/16/%E4%BD%BF%E7%94%A8-perf-%E4%BC%98%E5%8C%96%E7%A8%8B%E5%BA%8F%E6%80%A7%E8%83%BD/</guid>
      <description>因为原定deepin 15.7会做优化（能耗、资源占用等）方面的工作，所以在此之前，想提升一下团队整体的性能剖析、优化方面的水平，也就有了这次（周五）的培训。本来想用视频记录的，一个是自己回头能看看，反思和改进一下演说能力；另一个是以后有新人入职，我也就不用挨个再讲一遍，天不遂人愿，录制视频的软件半道挂了（ 所以只能这里尽量回忆当时想表述的内容，这里文字稿记录了。
下面就是培训内容：
好，人到齐了我们就开始了。今天要培训或者说要分享的内容是程序性能优化方面的内容，其实我们对性能优化不陌生：最开始接触龙芯和申威平台，系统组件间调用不是异步导致系统卡得无法使用；好不容易交了一个版本，控制中心各个模块还是因为切换卡顿、使用体验不好等做改进；前段时间为2G内存机器做优化等等。现在我们因为程序设计问题导致的性能问题比以前少了很多，一方面我们还要对这些部分持续改进，另一方面我们需要掌握一些性能剖析工具的使用，来帮助我们改进一些更细粒度的程序性能问题，今天我们主要集中在程序执行性能、也就是CPU占用这部分的性能优化。
今天培训的内容比较基础，还是老规矩，我做敲门砖，其余的还需要各位发挥。
刚才说了我们以前做了几次优化，我们再来回顾一下为什么要做性能优化。第一点肯定是占用过多的系统资源，不论是CPU、内存还是IO，如果系统组件的资源占用比较高，那系统资源有限、程序间的资源又是会互相竞争的，必定导致用户使用的应用程序的可用资源减少，在一些配置普通的机器上，可能就会导致第二个问题，也就是系统使用不够流畅，当然导致系统使用不流畅也分两部分原因，一个就是我们刚才说的，系统组件占用资源过多，另外一个也是刚才提过的程序架构设计有问题，导致卡界面等等；
第三个是性能问题在低配置的机器上会被无限放大，就像我们在最初的龙芯和申威平台一样，在x86上可能感受不到或者感受不太强烈的问题，在龙芯和申威上就会严重到无法使用（当然，现在的龙芯和申威平台使用已经没有问题了）；最后一个也是跟我们15.7想要解决的能耗问题息息相关，就是能耗高、发热大。主要是我们有些系统组件“不老实”，很多情况下随机“抽风”。
这个问题我们论坛用户提到的也不在少数：
当然了，大家可能也知道功耗主要跟系统配置关系很大，例如CPU开不开睿频、有没有设置节能模式，各个网卡、声卡驱动有没有设置节能模式等等，但是我觉得至少我们的程序至少不能成为能耗高的帮凶吧。
现在的情况是我们的程序不仅是帮凶，而且帮得很厉害，一会儿会给大家看一下。
刚才说了我们做了很多次性能优化，可能很多用户期待说我们能一次解决所有性能问题，但是实际上性能优化是持久战，它是一个需要持续做下去的事情。
另外主要还是因为性能优化很难，第一点主要就是性能瓶颈的定位很难，比如最开始我们系统登录的过程非常慢，所有程序都是并行启动，看着所有的系统资源占用都很高，换成串行启动以后，依然如此，这个定位当时就比较麻烦； 第二点是有时候优化的效果并不明显，虽然说我们看到有时候系统的资源占用挺高，但是可能分到每个程序中就不是特别多，做性能优化得慢慢抠，可能从单个程序来看效果并不明显；第三点是有时候做性能优化的技术和经验要求比较高，一方面是性能剖析工具的使用、对程序运行的本质要熟悉，另一方面就是要对被优化程序的代码要非常了解，不然就会导致我们说的第四个问题：优化可能影响正常功能。比如我上次给Dock提交了一个性能优化的提交，虽然有让sbw同学审核代码，但是最后还是导致了一个功能性bug。
虽说性能优化很难，但是……不积跬步无以至千里。所有复杂的系统都不是一天两天做好的，比如我们的桌面环境，到现在经过了四个版本，基本上就是四代人的心血堆积，才做成现在这个样子。
我们每个人都能做好自己那部分的话，众人拾材火焰高，解决系统性能问题我觉得没有那么麻烦，这其实也是为什么我这么迫切要组织这次培训/分享的原因，还是希望我做好敲门砖，像去年做高分屏支持一样，虽然是我开的头，但是其实最后基本上每个都比我做得好，最后我们做高分屏的效果也非常不错。
刚才说了性能优化很难，大家也不要害怕，其实性能优化也没有想象的那么复杂。
第一个是因为现在优秀的工具很多，比如右边这个非常出名的图，来自 Brendan Gregg 大神的博客。把系统性能优化每个部分对应的工具都清楚的标出来了。
第二个说实话是因为deepin的性能问题还比较多，比较容易发现，相应的上层的性能问题也多，所以说性能优化简单也是因为我们这次主要将注意力集中在 Applications &amp;amp; System Libaraies &amp;amp; System Call Interface这三部分即可。这部分的工具可以看到其实就是 perf、ltrace、strace这些，最多加上 bpfcc 、eBPF等。
说deepin性能问题还比较多是大家可以看到，静置状态下，我什么都不操作，几个组件就又可能时不时抽风一下（占用CPU部分）。
看到了有性能问题，但是我们总得有办法把这些性能问题优化掉吧。
性能优化一般分三个部分，第一部分就是查找程序性能热点，实际上一般我需要先定位性能瓶颈到底是在哪部分，是CPU？是内存还是IO等。不过我们这里目标很明确就是优化CPU占用，所以可以直接朝着有性能问题的程序去。
第二步是热点诊断和修复，找到了性能热点，我们肯定需要修复吧，看看导致这个热点的原因，正常进行修复即可。
第三步是回归测试，就像我们平常修bug一样，修了bug要测试，做了性能优化也一样，我们需要做回归测试、对比一下前后的性能数据。
我们先来看第一步，利用perf查找程序性能热点，这也是我们今天要说得重点。
perf这个工具最开始是作为Performance Counter的接口引入内核的，但是慢慢引入了一堆调试接口如 tracepoint、kprobe、uprobe等等，也就慢慢发展成为Linux几乎最好用的性能调试工具了。
我们平常使用的perf命令是用户态的工具，前面说得那些都是内核里面做的事情，内核态工具主要是对搜集到的数据和事件进行处理和统计。因为这个工具跟内核版本关系比较紧密，所以安装perf的时候需要注意跟内核版本对应的问题。当然，调试的时候装dbgsym包是必须的。
使用perf查找程序性能热点，一般主要用到三个子命令，第一个就是 perf top，这个很好理解，top命令大家都用过，那个top主要是针对进程或者线程级别的资源占用进行统计和展示，perf top可以理解为函数级别的top，可以动态展示系统目前占用资源最高的函数分布情况，它后面的 -g 是启用函数栈，-p 后面加上进程 PID就可以针对单个进程进行追踪，这个跟top命令一致，如果不加 -p 就是默认系统级的统计和展示。
第二个命令是 perf record，它跟第三个命令 perf report 是搭配使用的，record 用来记录一段时间内的程序执行情况，然后用 report 来进行展示。 -g 参数的意义跟 perf top一致，启用了函数栈以后，我们可以使用 &amp;ndash;call-graph 来制定使用哪种方式来获取函数栈：
 fp 方式，是使用传统的方式 frame pointer来获取堆栈，这个我在之前的文章中也介绍过；</description>
    </item>
    
    <item>
      <title>自制 Profiler 第二部分——调用栈回溯</title>
      <link>https://hualet.org/blog/2018/05/14/%E8%87%AA%E5%88%B6-profiler-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E8%B0%83%E7%94%A8%E6%A0%88%E5%9B%9E%E6%BA%AF/</link>
      <pubDate>Mon, 14 May 2018 14:19:37 +0800</pubDate>
      
      <guid>https://hualet.org/blog/2018/05/14/%E8%87%AA%E5%88%B6-profiler-%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%E8%B0%83%E7%94%A8%E6%A0%88%E5%9B%9E%E6%BA%AF/</guid>
      <description>书接上篇，我们现在已经能在其他程序中执行我们自己的代码，并且也做到了以固定的频率去执行采样代码（我们的printf），但是如何采样还是一个问题，这篇文章会就这这个问题继续探讨接下去我们面临的挑战——调用栈回溯。
为什么要获取函数调用栈？一方面是因为profiler除了要分析程序存在的性能问题，即函数执行热点以外，还需要帮助我们可怜的程序员找到问题的原因，这时候能提供问题函数的堆栈信息就非常必要了；另一方面，我们上一篇文章其实说了，是为了通过堆栈信息尽量还原程序的执行过程：试想一个程序执行的过程是 main-&amp;gt;funca-&amp;gt;funcb-&amp;gt;funcc，我们第一次采样 main-&amp;gt;funca，第二次采样 main-&amp;gt;funca-&amp;gt;funcb-&amp;gt;funcc，假如我们没有堆栈信息，我们只会统计一次 funca 和一次funcc，但是这并不能反应事实，相反，我们有堆栈信息的话，就会把 funca 、funcb 和 funcc 各计数一次，更能反应实际的执行过程。
概念 函数调用栈（Call Stack）和相应的栈帧（Stack Frame）我们其实都不陌生：在使用 gdb 调试程序的时候，bt（backtrace）命令打印出来的就是函数调用栈；而函数调用栈列表中的每一项则代表一个栈帧，我们执行 frame 命令跳转到某一个栈帧，其实就是一次回溯的过程。
想要在内存中解析出我们想要的函数调用栈，首先我们需要知道的就是一个程序的stack 段里面各个栈帧是如何布局的，要搞清楚这个，我们还需要了解一个概念叫：调用约定（Calling Convention），调用约定主要约定了（好绕）：
 函数的参数是如何传递的，是全都放到寄存器，还是全都放在 stack 段，还是混用两者； 函数的参数是按什么顺序放置到内存中的； 函数中的本地变量是如何分配的； 子函数调用是如何返回的； 子函数的栈帧是如何清理的； 等等  所以，调用约定基本上决定了函数调用中每个栈帧的产生、压栈、出栈对内存布局的影响，而这个约定是因架构和平台而异的。我们这里只关注x86 平台下的 cdecl 约定。
在这个约定下，假如我们有一个函数 DrawSqure 调用了 DrawLine （例子来自Wikipedia），那么程序内存布局中的 stack 段就应该是类似下图所示：
每个函数调用即创建一个栈帧，每个栈帧一次压入 stack 中。
其中，Stack Pointer(esp) 永远指向栈顶， Frame Pointer(ebp) 指向当前栈帧的中一个固定的地方（基地址）；函数参数以从右往左的顺序依次压栈，然后是压入Return Address ，它是当前函数（或者栈帧）执行完成后，程序要继续执行的指令地址， 同时压入父函数的栈帧基地址（Saved EBP），它是当前函数执行完成以后，Stack Pointer 和 Frame Pointer 将会指向的地方，基于这个地址，程序指令可以方便地访问函数本地变量（ebp负向偏移）和函数参数（ebp正向偏移）。
结合上面两张图，其实可以看出，每个栈帧其实都保存了上一个栈帧的基地址，因此所有的栈帧最终组成了一个链表，这也就是我们能拿到函数堆栈的理论基础了。
（注：上面只是粗略的讲解，参考链接 [1] 非常详细的描述了函数调用的过程中栈帧、stack 段和esp、ebp寄存器的变化，如果感兴趣，可以详细了解一下。）
参考方案 看完上面一大串概念以后，我们发现如果我们要按照函数约定的方式去获取函数调用堆栈，可以，但是太过蛋疼，而且不跨平台，很难受。 所以秉承不要重复造轮子的优良传统，我们发现有几个方式可以简单地获取到函数调用栈：</description>
    </item>
    
    <item>
      <title>自制 Profiler 第一部分</title>
      <link>https://hualet.org/blog/2018/05/13/%E8%87%AA%E5%88%B6-profiler-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</link>
      <pubDate>Sun, 13 May 2018 14:42:41 +0800</pubDate>
      
      <guid>https://hualet.org/blog/2018/05/13/%E8%87%AA%E5%88%B6-profiler-%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86/</guid>
      <description>​ 最近对性能剖析的技术颇感兴趣。好不容易来了三分钟热度，自然不能浪费，因此在余热消失之前研究并实践了其中一部分细节，对于其中一些知识点，个人感觉对于自身编程能力提升还是比较有益的，因此在这里写出来，抛砖引玉。
Linux profiler简介 ​ 性能剖析的工具，其实在Linux平台还是挺多的，比如小巧实用的strace、ltrace、latrace，大名鼎鼎的google-perftools、gprof、valgrind，以及瑞士军刀型的linux-perf等等，它们主要分为三个阵营，一个是针对程序执行的性能进行剖析，对程序执行的热点进行分析，如*trace、gprof这些工具；另一个是针对程序运行过程中内存的使用进行剖析，方便针对性地做内存优化，如valgrind；最后一部分就是“脚踏两条船”的，两个我都做，比如google-perftools、linux-perf这些，我们这个系列主要集中在“针对程序执行的性能进行剖析”方面。
Profiler的本质 ​ 要自制Profiler，首先要知道Profiler的本质是什么。简单来说，Profiler的本质其实就是在程序执行的过程中对程序正在“做什么”进行搜集和统计，如何搜集呢？无非两种：
 Instrumentaion - 程序主动Profiler告诉它在做什么； Sampling - Profiler自己间断性地去看程序在做什么；  前者的实现主要依靠程序运行时提供的某些钩子机制、代码插桩等方式，例如gprof主要是依靠 gcc 在编译程序的时候”夹带私货“来达到程序运行的时候主动提供给gprof采样样本，来达到事后分析的目的[1]。这种方式相对来说虽然比较可靠、准确，但是对于无法控制编译条件的程序就比较无可奈何了。
后者的实现则主要是定期对程序当前执行的指令和对程序执行的函数堆栈进行回溯（unwind）来尽量还原程序执行的过程，例如google-perftools就是采用这种方式，这种情况下，采样的周期就显得尤为重要。
​ 对比以上两种方式，我们果断采用第二种。
​ PS: 这里需要说明一下的是，利用ptrace系统调用完成工作的strace和ltrace，虽然不依赖编译器夹带私货，但是相当于依赖了内核的“钩子”，不属于sampling的范围；同样，latrace则是依赖了ld的LD_AUDIT“钩子”，也不属于sampling的范围。
Profiler启动 ​ 那么问题又来了，ptrace没得用，我们怎么去获取被剖析程序的执行状态呢？总不至于profiler要搞成root权限的吧？答案是：不，内核管天管地，总管不到程序自己偷看自己的数据吧？我们想办法把我们的代码塞到被剖析程序中去就可以了！
​ 刚才提到了ld的LD_AUDIT，这次就轮到它的兄弟——大名鼎鼎的LD_PRELOAD——登场了。想法是这样的，我们的profiler其实只需要在程序开始的时候执行一个定时器，以后每次定时器执行的时候去抓取我们的样本就OK了，所以我们完全可以把自己伪装成一个人畜无害的动态库，等到别个程序有意无意加载到我们，哼哼……事实上，很多profiler都是采取类似的策略，比如google-perftools，再比如heaptrack等等。
编码实战 ​ 废话少说，放码过来！
​ 我们在QtCreator中创建一个动态库项目 simple-profiler，主类 SimpleProfiler。首先，我们需要设置好我们的定时器：
void SimpleProfiler::enableProfile() { int ret = setitimer(ITIMER_PROF, &amp;amp;m_tick, nullptr); if ( ret != 0) { fprintf(stderr, &amp;quot;failed to enable profiler: %s&amp;quot;, strerror(errno)); } }  根据 setitimer 的man文档，计时器主要有三种类型：
 ITIMER_REAL 这个计时器是根据墙上时间进行倒计时，最终触发 SIGALRM 信号； ITIMER_VIRTUAL 这个计时器是根据进程花费在用户空间的 CPU 时间进行倒计时的，最终触发 SIGVTALRM 信号； ITIMER_PROF 这个计时器是根据进程话费在用户空间和内核空间的 CPU 时间进行倒计时的，最终触发 SIGPROF 信号；  个人认为，假如都是用在 profiler 上的话，第一种计时器用来查找程序执行慢（某个函数有IO等情况）的瓶颈比较有效果；后两种计时器用来查找程序 CPU 占用瓶颈比较有效果。不过使用第一种计时器的话，对被追踪程序的执行影响相较于后两者就比较大了，所以这里采用第三种计时器。</description>
    </item>
    
    <item>
      <title>初探Linux内核态——通过proc文件系统作快速问题定位</title>
      <link>https://hualet.org/blog/2018/01/23/%E5%88%9D%E6%8E%A2linux%E5%86%85%E6%A0%B8%E6%80%81%E9%80%9A%E8%BF%87proc%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%BD%9C%E5%BF%AB%E9%80%9F%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/</link>
      <pubDate>Tue, 23 Jan 2018 19:59:00 +0800</pubDate>
      
      <guid>https://hualet.org/blog/2018/01/23/%E5%88%9D%E6%8E%A2linux%E5%86%85%E6%A0%B8%E6%80%81%E9%80%9A%E8%BF%87proc%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%BD%9C%E5%BF%AB%E9%80%9F%E9%97%AE%E9%A2%98%E5%AE%9A%E4%BD%8D/</guid>
      <description>文章翻译自 Peeking into Linux kernel-land using /proc filesystem for quick’n’dirty troubleshooting
这篇博客的内容完全是关于现代Linux内核的。换句话说，指的是与RHEL6一样使用的2.6.3x系列内核，而不是古老的RHEL5所使用的2.6.18内核（都什么鬼了？！），虽然大部分企业都还在使用RHEL5。另外，这篇文章也不会涉及内核调试器或者SystemTap脚本之类的东西，完全是最最简单地在有用的proc文件系统节点上执行“cat /proc/PID/xyz”这样的命令。
定位一个程序“运行缓慢”的问题 下面要举的这个例子是这样的：一个DBA反映说他们的find命令一直运行缓慢，半天都没有什么输出，他们想知道这是为什么。听到这个问题的时候我就大概有直觉造成这个问题的原因，但是他们还是想知道怎么系统地追踪这类问题，并找到解决方案。刚好出问题的现场还在……
还好，系统是运行在OEL6上的，内核比较新，确切地说是2.6.39 UEK2。
首先，让我们看看find进程是否还在：
[root@oel6 ~]# ps -ef | grep find root 27288 27245 4 11:57 pts/0 00:00:01 find . -type f root 27334 27315 0 11:57 pts/1 00:00:00 grep find  跑的好好的，PID是27288（请记好这个将会伴随整篇博客的数字）。
那么，我们就从最基础的开始分析它的瓶颈：如果它不是被什么操作卡住了（例如从cache中加载它所需要的内容），它应该是100%的CPU占用率；如果它的瓶颈在IO或者资源竞争，那么它应该是很低的CPU占用率，或者是%0。
我们先看下top：
[root@oel6 ~]# top -cbp 27288 top - 11:58:15 up 7 days, 3:38, 2 users, load average: 1.21, 0.65, 0.47 Tasks: 1 total, 0 running, 1 sleeping, 0 stopped, 0 zombie Cpu(s): 0.</description>
    </item>
    
    <item>
      <title>15.5研发心得</title>
      <link>https://hualet.org/blog/2017/12/04/15.5%E7%A0%94%E5%8F%91%E5%BF%83%E5%BE%97/</link>
      <pubDate>Mon, 04 Dec 2017 21:26:48 +0800</pubDate>
      
      <guid>https://hualet.org/blog/2017/12/04/15.5%E7%A0%94%E5%8F%91%E5%BF%83%E5%BE%97/</guid>
      <description>迟到的经典 2017年11月29日，农历十月十二，经过一番挣扎，deepin 15.5的ISO终于安静地躺在了内网服务器上，静待着属于它的时刻的到来。
是的，deepin在重新定义了十月一日为农历十月初一以后，甚至连“保证月底发布”的底线也没有守住，妥妥地把发布时间拖到了十一月（阳历）中旬。即便如此，我也觉得这次“迟到”是值得的，在“手机不赚钱，交个朋友”的时代，PC操作系统的研发需要特别用心，才能留住那些对我们期待了那么久的用户朋友。我想，在未来可以预见的时间内，所有deepin的用户都会记住这个特殊的版本号：15.5。这个能让我们在视觉体验上有质的飞跃，在应用包格式上走在世界前面，自带修复工具箱——live修复系统，并且在稳定性和易用性上大幅提升的版本。
deepin15.5注定成为经典。
故事 按照传统，一年中各大版本的主要功能都是预先定义好的，搭配一点重要的bug修复和用户体验改进，基本上就妥妥的了。但是15.5是个奇葩。在七八月份定义15.5详细需求的时候，我们梳理github上的issue，发现一条一岁半“高龄”的主题，大意是“跪求高分屏支持”；同样早在16年初，公司成立了一个神秘的组织叫“Alpha Team”，这个小组的第一个任务就是“独立包格式”；在记忆都稍微有点模糊的14年，就有用户想要在deepin下创建热点……这几个严重拖延的任务让人汗颜，所以我们当时就任性地决定15.5主要来解决这些问题。虽说是决定，但是并没有人特别自信，“毕竟是拖了这么长时间都没有解决的问题”，再加上高分屏涉及面太广，深度全家桶都要“挨刀子”；独立包格式本身社区也不统一；WiFi热点挑硬件，Linux下的网卡驱动又不都是那么好……越想越恐怖。
“要不再加点其他任务？”，我提议。 众人惊恐状。 “这样万一前面几个任务完成不了，做点其他任务应付一下老王嘛”。
逆向思维有时候还是挺管用的。
就这样，像是一锅羊肉火锅一样，15.5的配菜变成了主菜，也就是前面提到的三个点；又加入了新的配菜，VPN导入导出、应用代理、触摸板手势、色温调节、bug修复和其他一大波新应用等。
当所有人都以为15.5就这样的时候，一个不识趣的朋友跟老王说我们系统的恢复模式进不了root，所以系统一旦出了问题就只能靠重装大法解决。我闻风一边心想绝对不可能，一边赶紧试了下，结果是果然不好用。 还没等我返回神儿来，老王已经在Tower上建好了“live系统支持”的任务。
高分屏 高分屏支持的话题由来已久，大概是在我刚进入deepin(14年）的时候就有人在“布局”：图片资源一定要用svg、尺寸不能写死等等，然而坚持了一段时间以后，大家发现这种坚持似乎毫无意义，因为没有人用高分屏，自然发现不了高分屏那种细腻到看不到“痘痘”的美，于是乎慢慢地各种png、死尺寸就满天飞了。
俗话说“出来混总要还的”，因为以前的任性，在适配高分屏的过程中，deepin团队可谓吃尽了苦头。不仅几乎所有程序中用到的图片资源都要重新绘制（还好图标主题一直坚持svg），还差点在x2.png的道路上栽了个跟头，还好悬崖勒马，及时止损。
普通应用适配高分屏在如今的环境下，Qt和GTK等界面库的高分屏支持已经比较成熟，还算是比较简单的。但是桌面环境和一些特殊应用，如启动器、截图、录屏等，就需要些功夫了，在适配的时候还要考虑缩放前后的窗口大小、窗口位置等等，恰巧这些地方Qt的处理又比较坑，有时候实在受不了了，只能patch Qt来处理。
看图的适配也比较麻烦，很多地方都用到了缩略图。缩略图也要支持高分屏！听起来有点好笑，但事实是不仅是缩略图，很多情况下一条线、一个圆角的瑕疵，在高分屏下都可能被放大，变得非常恼人。
15.5的细腻就是在这种情况下“磨”出来的。
Flatpak Flatpak其实原名叫“xdg-app”，可能后来觉得不够高端大气，配不上“The future of application distribution”的名头，遂改名Flatpak。
按照官网的说法：
 Flatpak is the next-generation technology for building and installing desktop applications. It has the power to revolutionize the Linux desktop ecosystem.
 Flatpak将会改变Linux世界的生态。
不谋而合，同样这样想的还有snap技术。
snap是Ubuntu为了布局服务器和容器市场推出的一套解决方案，与Flatpak类似，它也是利用Linux内核提供的沙盒机制和方案，再加上一套包分发、安装、更新和卸载的辅助系统，来实现应用与系统隔离的想法，以解决目前Linux世界包分发过程中经常让人头疼不已的依赖问题和系统安全问题。
在两者之中，deepin毅然选择了Flatpak，为什么？因为从Mir vs Walyland的例子中，我们发现一个非常真实地存在于开源世界的“潜规则”：“政治不正确”的项目，在开源世界中一般是无法长久的，其中所谓的“政治不正确”其实就是“g家族”已经有同样的项目存在，又有人造了“轮子”。所以，与其寄希望于一个可能不能长久的项目，还是在Flatpak上孤注一掷来得靠谱一点。
想法虽然显得投机了点，但是像往常一样，deepin团队做起实事来一点也不含糊。深度全家桶中的成员，非系统级的应用，全数被打成了Flatpak包。重要的是，这些Flatpak包已经在15.5的ISO中替换了原来的deb包，也就是说deepin 15.5可能是全球第一个预置了Flatpak和自家应用的Flatpak包的发行版了。
“少数人活在未来，人们中的大多数则是静待着未来的降临，这是整个人类文明的演进方式”，最近耳朵里总是充斥着这样的声音。我想deepin团队在推动Flatpak上是走在世界前列的，为身处这样的团队感到骄傲。
live修复系统 对于喜欢折腾系统的用户来说，这次可能最期待的就属live修复系统了，它是个什么东西呢？可以这样简单理解，live修复系统就是一个超级mini版的deepin系统：除了量身裁剪过的DDE外，只预装几款必要的系统工具。最重要的一点是，live修复系统独立于你所安装的deepin系统，完全运行于内存中，这样，你就不会遇到在你修复系统到一半的时候系统弹出警告框，告诉你需要卸载某个磁盘之类的尴尬情况了。
在live修复系统中，预置有深度全家桶的一位新成员“深度备份还原工具”。这个工具具有化腐朽为神奇的超级牛力，它可以助你轻轻松松地把老系统上的数据迁移到你的新硬件上：全新的机器内部，还是熟悉的老伙计——deepin。
live修复系统为了保持简单、简洁，目前除了必要的浏览器、备份还原工具和终端外，并没有预置更多的工具和应用，毕竟要完全跑在内存里嘛。在系统中安装上live修复系统，打开启动器，你甚至感受不到它的存在！因为它的入口确实不在启动器里面，而是在grub菜单。好的功能/用户体验就是这样，需要它的人一定知道它在哪，不需要它的人完全没必要因为每天都能看到它而感到不自然。
在可预计的将来，应该会有更多实用工具登陆live修复系统，让你进入live修复系统，就感觉到自己像是被武装到了牙齿。
其他 每次介绍新功能，都不得不辟一个“其他”的栏目，因为新的变动实在太多，其中有些像网易云音乐新版一样，内部真刀实枪地大改造（用qcef替换原来的webkit），但是用户可能不会有太多直接感知的；还有一些“彩蛋”类的像是本次的“自动色温调节”，有些用户发现这个功能后溢于言表，幸福感可能都超过了使用这个功能本身的；另外的一些工具类，如Wi-Fi热点、VPN导入导出的工具类功能，天生就是理科男的命——绿叶。
在deepin系统的完整度方面，指纹识别算是这次的另外一个亮点了，如果你的电脑配备了指纹识别器，那么升级到15.5，你将从输入密码这项繁琐的工作中解放出来，一切都是那么顺滑。</description>
    </item>
    
    <item>
      <title>给小崔的基础管理课</title>
      <link>https://hualet.org/blog/2017/11/05/%E7%BB%99%E5%B0%8F%E5%B4%94%E7%9A%84%E5%9F%BA%E7%A1%80%E7%AE%A1%E7%90%86%E8%AF%BE/</link>
      <pubDate>Sun, 05 Nov 2017 21:26:48 +0800</pubDate>
      
      <guid>https://hualet.org/blog/2017/11/05/%E7%BB%99%E5%B0%8F%E5%B4%94%E7%9A%84%E5%9F%BA%E7%A1%80%E7%AE%A1%E7%90%86%E8%AF%BE/</guid>
      <description>最近小崔的日子好像不太好过，负责一个项目的同事发了farewell letter，于是她被莫名其妙地选中来担任整个项目的负责人。 这突如其来的变动，打了小崔一个措手不及：因为给同事分配任务不顺利气哭、因为担心第二天的工作是否能很好完成而失眠……就跟我刚开始担任深度桌面组组长的时候一摸一样。看着实在心疼啊，于是趁着今天天气好出去晃悠的时候顺便跟她传授了一点小小的经验，这里顺便记录一下，希望对有需要的朋友有所帮助。
在说初级管理的经验之前，我想强调一下“自信”，因为这是我觉得一个人能做成一件事情最基础的基础。如果连自信都做不到，那就不要妄谈管理了，你甚至连自己都做不好。小时候我妈一直说谦虚使人进步、骄傲使人落后，让我平时谦虚一点。我当时想不通，现在依然想不通，我甚至觉得自负要比自卑强得多，这是因为自信心实在是太难培养了。比如我虽然一直对自己的学习能力和技术比较（盲目）自信，但是我刚做管理的时候，其实也不自信能把所有人捏到一起、团结起来，但是因为心里面有执念觉得不能把做不到跟自己扯上关系，所以还是努力地去尝试，很清楚地记得有一次我当着所有人的面把自己的完整解决方案说出来那一刻，我的自信心才完全建立起来，之后的管理就相对容易了很多。说到小崔，我大概是不担心的，她只要把自己在镜子前臭美的状态转化一下，自信心应当是爆棚的 😄
自信做好了，用来做什么呢？这就是管理的内容了，管理不再是扎头自己的事情，而是掌握大局，在掌握大局以后在处理非自己处理不可的事情。什么是掌控大局？我觉得分两个部分：承上和启下，承上就是了解清楚上级的需求和工作内容；启下就是把需要做的事情分配给自己的组员，让他们清楚自己工作的内容，这个部分其实是管理的核心，后面会提到我的秘诀！什么又是非自己处理不可的事情？这绝不是自己什么都不做，所有事情一股脑塞给下属同事，而是在了解清楚工作内容以后，把那些能提升团队工作效率的事情或者实在是只有自己才能做的事做了，自身做则才能做到服人。
因为初级管理承上启下的特点，所以这种工作其实有时候特别难做。我从朋友那里学到了十个字，感觉对我的管理工作有着非常关键的指导作用：对上要有胆，对下要有心。仔细揣摩一下，其实不难发现这其实是在约束一个管理者的行为：面对上级领导的时候，不要老感觉自己是个小兵，要大胆跟对方进行沟通，因为你代表的不仅仅是你自己，还有自己的下属同事；面对下属同事的时候，不要感觉自己官大一级压死他们，其实你跟他们是与荣俱荣与损具损的共生体；这对初级管理尤其重要，因为初级管理更像是战场前线的班长，你连面对自己上级的胆量都没有，何谈面对敌人的炮火？你不把自己的班子成员当兄弟，谁会给你当炮灰？
当然，就算你做好这些了，做得非常好了，也不一定能让团队里面所有的人都服你，你一样会遭受挫折、遇到不顺利；这里首先要想到的就是：“如果这件事情简单，哪还需要老子上？” 在这种心态/格局下，再去看待问题可能会更容易接受一些；做管理，容忍度一定是要有的，因为林子大了什么样的鸟都有，在一时半会改变不了别人的情况下，只能让自己学会接受现实，伺机而动。情绪控制也是要有的，下属情商不够，也不能让自己失控，有情绪很正常，不然变成一个冷血的混蛋，没有人会跟你真诚，这样的管理就像是古代的暴政，总会被推翻的。有情绪代表你是一个有血有肉的人，但是也不要让情绪化过多干扰自己的理智，最最基础的也是要做到不要让情绪影响到工作。
这看起来很难，但是只要转换心态就可以让自己好过很多，比如你给对方分配任务，对方无理由拒绝或者态度恶劣，你可以想：“对方拒绝做或者做不好的事公司的事情，又不是自己的事情，犯不着跟对方闹情绪”。对，管理就是要这么灵活，该把公司的事当成自己的事的时候，拼死了干；该把不相干的事情甩出去的事情，就要爽快的甩出去。至少这个时候你无能为力了，这样安慰安慰自己，让自己平复情绪还是很有用的。不要怕沟通，尤其是跟刺头的沟通！那天做到了“今天就算是吵翻了天，明天还是要像一个没事人一样去跟对方相处”，基本上在这方面算是合格了。
还有一部分没有跟小崔聊的，大概涉及到项目管理的事情，还比较重要，所以提一下。分出去的任务，要定期做检查，毕竟公司有管理是为了管人，但是最终的目的是把事情做好。分出去的任务，反馈回来的至少需要有完成的时间和安排，拿到安排后按照自己的经验核算一下是否合理，如果不合理就需要跟对方再进行沟通，合理的话还要提前检查，不检查的时间相当于没有定！其实项目管理的精髓就是这个：计划、检查和沟通，其他的方法论都是技巧性的表皮罢了。
根据我这几年的工作和生活经验，说一下我的“困难观”。面对困难一般有两条路可选，第一是消极面对，相信这个事情总会能熬过去的，等熬过去了，又是春光明媚。这种一般在面对自己完全非自愿但又不得不去抗的事情时用来安慰自己，让自己不至于分裂、崩溃；另一个是积极面对，相信自己的聪明，找到问题的关键，搞定它，解决这个困难，你自己也会有所提升；这种情况我一般都把困难拆分成一个一个的难题（拆解问题的能力也很关键，因为暂时不需要，等以后再聊），像福尔摩斯一样运用自己的智慧去解开每个难题的答案，这样的面对困难重重的生活才不会觉得枯燥无味。
最后，不管使用哪种方式处理现在项目上的问题，我觉得都是对自己的一种磨砺吧，希望小崔可以顺利度过难关 :3</description>
    </item>
    
    <item>
      <title>神奇的isatty</title>
      <link>https://hualet.org/blog/2017/08/29/%E7%A5%9E%E5%A5%87%E7%9A%84isatty/</link>
      <pubDate>Tue, 29 Aug 2017 21:26:48 +0800</pubDate>
      
      <guid>https://hualet.org/blog/2017/08/29/%E7%A5%9E%E5%A5%87%E7%9A%84isatty/</guid>
      <description>前些日子才从apt-get命令系列换成更为时尚的apt系列，作为一个debian系发行版——deepin的开发者，我表示很汗颜……新的apt命令除了在功能上将apt-get、apt-cache等几个命令统一到了一个命令上外，更是有了不错的TUI，如文档所说：
The `apt` command is meant to be pleasant for end users and does not need to be backward compatible like apt-get(8).  毕竟，还多了进度条呢…… 😂
不过这不是今天要说的重点，换到apt以后，把apt操作的一些结果跟管道结合一起用，经常会收到警告，例如：
(ssh) hualet@hualet-PC : ~ [0] % apt search deepin | grep -i superstar WARNING: apt does not have a stable CLI interface. Use with caution in scripts.  CLI的输出也算是API要保持stable么？汗颜again……dtk作为一个系统级的开发库都还没有到stable的状态、某in公司的CTO写得命令行工具，第二天接口就全变了😂……敬畏之余，困惑我的倒不是这个警告的内容，毕竟新的东西都不保证稳定么，但是apt是怎么知道它的输出被连到管道了呢？
一直没空处理，直到昨天，又一次遇到了，遂记下，晚上思来想去没什么想法，遂请教前文提到的不靠谱CTO，丫直接甩过来一句：
“istty检测output啊，很多命令行程序都会根据这个做不同的反应”
我：“man istty没有结果啊“
他：”你man page没装全吧？“
我默默敲下sudo apt install manpages-dev，显示已经安装了……
我：“装全了啊，我Google一下吧”
他：“肯定没装全，应该是在libbsd或者termios里的吧……“ 信誓旦旦。
我默默Google了一圈，发现那个函数其实叫isatty，在unistd.h里面定义
我：“你是不是记错了，有isatty，unistd.h里面的……”</description>
    </item>
    
    <item>
      <title>输入法消失之谜</title>
      <link>https://hualet.org/blog/2017/08/05/%E8%BE%93%E5%85%A5%E6%B3%95%E6%B6%88%E5%A4%B1%E4%B9%8B%E8%B0%9C/</link>
      <pubDate>Sat, 05 Aug 2017 21:26:48 +0800</pubDate>
      
      <guid>https://hualet.org/blog/2017/08/05/%E8%BE%93%E5%85%A5%E6%B3%95%E6%B6%88%E5%A4%B1%E4%B9%8B%E8%B0%9C/</guid>
      <description>最近不少用户在deepin论坛上报告说搜狗输入法的图标不见了，收到反馈我就心想坏了，我的输入法图标很早前就消失不见了，之前发现这个问题但是没有去跟踪是因为没有看到其他同事出现类似情况，我的电脑平常为了调试用户反馈的bug又经常XJB装软件，觉得是个例。现在收到多人反馈，大概又是什么“更新事故”？
带着沉重的心情，首先要确定的是这个问题影响的范围：
 15.4.1的ISO是不存在这个问题的； 不用输入法的老外是没有受到影响的； 只有少量论坛用户报告了这个问题，大部分人表示更新到最新也没有这个问题；  还好影响范围还比较小，那么下一步就是找解决办法了：
 想办法绕过？对于这个问题来说好像不太好使； debug找到问题的根本原因；  （注：其实用户反馈是集中在这两周的时间甚至更短，如果是其他人的话可能会去排查最近更新了什么包，但是我刚好很早以前遇到了这个问题，受其干扰，所以走了一条冤枉路……）
下面进入本文主题，怎么去debug？以前压根儿没有调过输入法的问题啊，遂去请教公司大神，大神表示：”我也不知道啊 （无奈脸 ”～ 那么我们只能瞎猜了：
第一步：卸载掉搜狗，排除是否是搜狗输入法（问题多多，值得怀疑）导致的。
结果显示卸载掉搜狗输入法以后，小企鹅的图标可以正常显示，看来果然是搜狗输入法导致的？
第二步：下载官方搜狗搜狗输入法，重新安装，排除搜狗输入法版本的问题。
重新安装后没卵用。但是突然想起来搜狗在家目录下的.config/sogou-qimpanel/skin 里面有皮肤缓存，据Google说是皮肤有可能导致输入法图标不见的问题……我们在做2D极速版适配的时候，玩了点黑魔法，替换了一些资源文件，可能是改坏了什么东西？
第三步：删除皮肤缓存，排除修改皮肤的问题。
没卵用…… 陷入僵局，但是发现如果将sogou-qimpanel这个进程杀掉，输入法的图标就会显示出来了……那么估计是这个进程负责读取sogou的皮肤文件然后更改输入法图标，中间可能出现了什么岔子？
第四步：使用strace跟踪sogou-qimpanel，感觉胜利在望。
$ killall sogou-qimpanel &amp;amp;&amp;amp; strace -e open sogou-qimpanel  打印着打印着，吭哧，sogou-qimpanel尼玛居然退出了……什么鬼，再次尝试，还是退出了。看来是daemonize了？那么strace attach到子进程呢？貌似关键的信息已经丢了……陷入僵局……
如何在系统级别追踪呢？？？
第五步： 看来要祭出大杀器systemtap了，随手写（抄）了一个stp：
probe syscall.open.return { printf(&amp;quot;%s %s&amp;quot;, filename, execname()) }  运行失败……
WARNING: never-assigned local variable &#39;filename&#39; (similar: name, __nr, retstr): identifier &#39;filename&#39; at sogou_qimpanel_open.stp:2:20 source: printf(&amp;quot;%s, %s&amp;quot;, filename, execname())  请教公司另外一大神，大神表示“你装一下kernel的debug包就行了……” 结果，还是不行……坑……</description>
    </item>
    
    <item>
      <title>2016年终总结</title>
      <link>https://hualet.org/blog/2017/01/02/2016%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</link>
      <pubDate>Mon, 02 Jan 2017 21:26:48 +0800</pubDate>
      
      <guid>https://hualet.org/blog/2017/01/02/2016%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</guid>
      <description>自从开始上班，每年年终总结都少不了，因为都是给老板看的，内容无非是今年我做了什么事情、多牛逼、对公司贡献多大云云，万一老板看到一件他不记得但是你写下来的工作贡献一高兴，说不定给你升职加薪，一年也就不算白干了。但是，写给自己的年终总结哪能这么应付，梳理整理自己一年的得失，做好权衡，最重要的是吸取经验做来年的规划。
2016关键词：累、读书和成长 2016年是挺累的一年，不知道是不是整个前半年和2015年的后半年都在加班的缘故还是什么，即便是后半年没怎么加班的时候，也没感觉怎么轻松。其间必然有些成绩，但也带来了很多严重的问题，例如我长期状态不佳、思维不清楚等，总是感觉有点得不偿失。最后的两个来月，我都在认真思考这些现象产生的原因，总结下来问题可能出在两个地方：
一、工作方式不佳，最主要的问题是贪多和多任务并行；
从年初接下来整个社区版的发布和维护工作以后，整个人进入了一种所有事情都想帮着处理的状态，写代码、管理、调试问题、支持售前、支持工程、社区反馈等等，一天到晚地干，似乎没有什么尽头；以至后面养成了多任务并行的坏习惯，做什么事情都集中不了精神，长此以往，不要说提高工作效率了，整个人都快废了。
二、生活方式不佳，最主要的问题是不够自律；
深度一天的工作时间如果不算加班其实到不了8小时，但是这个不到8个小时中我几乎有7.5个小时都在写代码（大部分工作日，有些需要讨论产品需求、开会等略去），中间几乎没有任何break，这几乎回到了14年中的工作生活状态——我几乎丧失了良好的口头交流的能力；这样的一天下来，晚上能干嘛呢？吃饭、游戏和睡觉呗……但是，问题是有些时候还要加班，加班完了回到住的地方连玩儿会儿电脑都不能就睡觉也太“亏”了吧？于是控制不住自己的玩儿过了睡觉时间，长期睡眠不够，这也直接导致了我思维变得特别慢。
确定了问题根源，肯定要治病根儿啊，针对工作方式的问题，我开始强制自己使用番茄钟，并尽量将自己的任务分摊开来；针对生活方式的问题，除了尝试早睡早起外，我也开始尝试跟别人闲聊（主要在微信上），让自己的大脑变得活跃；顺便逼迫自己抽出时间来读书，读书这件事情既能涨知识，还能磨练耐性、让自己的注意力集中起来。
说起读书，16年后半年读的一本非常火的书《软技能——代码之外的生存技能》，它之所以火，我想主要是因为它似乎给程序员打开了一扇门，这些平常只会钻研技术、敲代码的人突然发现，卧槽原来这不是生活啊！一直觉得程序员们是一群很神奇的物种，他们自认为是世界的主宰，但是真相是他们简直是生活不能自理……同时，这群脑子很聪明的人，比其他人更容易接受改变和思想上的冲击。至少这本书让我开始反思自己对待生活的态度、对待薪资的态度、对待投资理财以及社交的态度；书与其说始给程序员写的，到不如说始给所有人写的人生规划课程：学习新技能、找到新工作、营销自己、自由职业、理财和投资等等，我觉得工作的人都应该看一下。
另一本值得一提的书《梁启超教子家书》，这本书我觉得我要么评0分，要么评100分，它好是好在书里面梁启超的家书原文，至于作者整理的一些结论，个人觉得没什么可以吸收的东西。从那么多的家书中，除了可以窥探一番我比较神往的民国生活，从中理解出来的梁启超让我对这个历史人物有了翻天覆地般的认知改变。梁的爱子、博学、社交和投资，这跟前面的《软技能——代码之外的生存技能》这本书似乎遥相呼应，就是在告诉我，你需要改变了！
当作故事读的书例如《红顶商人胡雪岩》和《老残游记》等，其实给我的启发也是蛮大的，胡雪岩的冷静、睿智和大方，老残的淡泊、生活观和使命感（包括作者刘鹗的经历），都让我在生活中处理一些事情的时候有了些个参考；带着功力目的去读的《旅行与读书》、《逻辑思维——成大事者不纠结》等，也能按照预期给我涨涨见识；不期而遇的《解忧杂货铺》，读起来酣畅淋漓，故事也够精彩；2016年（后半年），在微信读书上花费时间116个小时，完整读完的有8本书，还有些零散着读一些丢一些的，这一年也算是个好的收场了。
说起成长，首当其冲的就是经历了一次分手和复合，其中酸甜苦辣，旁人绝不能理解，对我也是一次比较大的考验，让我对待生活、对待另一半有了跟之前完全不一样的转变，我很庆幸这些事的发生在25岁，而不是更晚；2016年我也开始感受到了生活的压力、结婚买房的压力，这些压力促使我去做一些改变，去践行我在书中、在生活中学到的一些生活方式，去担负起责任；这一年通过工作，我更加了解自己的成熟范围和做事风格，我愈加能够掌握做事的分寸。
2016，这是非常精彩的一年。
2017目标关键词：高效、读书、旅行 高效分两个，一个是专注于一两件关键的事情，做好；一个是调整自己的工作状态；读书不消说，这是个会上瘾的东西，好书推荐好书，好书推荐好人，好人又推荐好书，无穷尽也；旅行业分两块儿说，一是出去走走，二是组织一些线下聚会；做到这些2017年也将是非常精彩的一年！
另外，2017年准备把份子钱都收回来，哈哈哈！</description>
    </item>
    
    <item>
      <title>12月10日回洛阳记</title>
      <link>https://hualet.org/blog/2016/12/14/12%E6%9C%8810%E6%97%A5%E5%9B%9E%E6%B4%9B%E9%98%B3%E8%AE%B0/</link>
      <pubDate>Wed, 14 Dec 2016 21:26:48 +0800</pubDate>
      
      <guid>https://hualet.org/blog/2016/12/14/12%E6%9C%8810%E6%97%A5%E5%9B%9E%E6%B4%9B%E9%98%B3%E8%AE%B0/</guid>
      <description>2016年12月10日，我们宿舍老五结婚的答谢宴，刚好又在我们大学所在的城市洛阳举行，哥们儿几个商量着都回去一趟，互相见见自己几位久未蒙面的兄弟，到场的有深圳来的老大、洛阳本地的老三、新乡来的老四、东道主老五、上海来的老六、北京来的老七和武汉来的我。能够成行着实不易，简单记录一下，留作纪念。
9号晚上从武汉出发，卧铺10号早上到的洛阳。下车发了一个朋友圈： “毕业后就没有来过的城市 洛阳，你有点冷啊😢” 相比江城武汉，洛阳显得要冷得多，去的时候觉得“绝对没问题”的羽绒服已经显得不太够用了。火车站旁边的公交车站，虽然大早上已经开始忙碌起来，但还是那么井然有序；又冷又困，我给五哥打了个电话，问清楚酒店地点，上了熟悉而又陌生的68路。
时间过得总是飞快，上面一幕幕清晰的画面，在现在我码字的时刻，已经是两三天前的场景。这次回洛阳，除了兄弟们一块儿给老五庆祝了婚礼，一块儿吃吃喝喝，还顺带逛了我们的新、老校区，觥筹交错的瞬间，总是感觉回忆满满：
想起了新生报道，先来的瓜分五个下铺；想起了新生拍照，霸气的女生周培一怒之下甩了照相老师一脸；想起了第一次在大学过自己的生日，整个宿舍一块儿出去吃饭，喝了四年最多的一次啤酒（12箱？）；想起了用别人的mp4，每天窝在宿舍，一年看了比前18年看得电影总数还多的电影；想起了因为被班长逼着去参加脑残活动，甩了班长一脸；想起了跟宿舍人一块儿打篮球，80后vs90后，打中锋，单手抓篮球；想起了09年大雪，排长队走雪中的一条小径去食堂吃饭，重庆来的老八因为没见过下大雪，翘课出去看雪；想起了唯一一次看世界杯，跟着球迷舍友在4号教学楼一块儿嘶吼；想起了第一次参加文艺晚会比赛，唱王力宏的《龙的传人》；想起了用老九的手机，看电视直播《武林风》；想起了从老大哪里看到的《藏地密码》，他没有看，反而一口气被我看完；想起了一个夏天晚上跟着看了《午夜凶铃》，一个星期没有睡好觉；想起了那个夏天睡宿舍楼顶，早上的大太阳晒的皮肤瘙痒……
想起了联盟公寓，我买了不到一周的自行车丢了；想起了联盟食堂的面条；想起了洛阳公交车，能随时为了老弱病残停车；想起了人生中第一次去电影院看电影《加勒比海盗4》，也是我看的第一部3D电影；想起了小崔来洛阳找我，跟做梦一样；想起了跟舍友一块儿去做兼职，促销九阳豆浆机，一连站了七天；想起了有虫子的宿舍，宿舍的人不得不三番两次把床板拿到下面用热水烫；想起了我独自上自习，陪过看了所有计算机专业课本的自习室；想起了同样的自习室，小崔因为放了个响屁，非要让我去领她；想起了差点挂掉的机械设计和机械原理，那课压根儿没人愿意上；想起了偶然发现的一个评四大名著的选修课，晚上冒雨也要去听；想起了龙潭峡、天池山，那些洛阳周边的风景区和无忧无虑的大二时光；想起了大家一起看《那些年我们一起追的女孩》，一起听《让青春继续》……
那天晚上一直玩儿到2点，在KTV唱歌从流行歌曲一直唱到《猴哥》、《葫芦娃》……回酒店又聊天到四点，好像恨不得以后的话就在那天晚上能说完；但是该来的还是回来，老七要去郑州买房子、老大要赶飞机，天下没有不散的筵席，喝碗牛肉汤，各自上路。</description>
    </item>
    
    <item>
      <title>楼兰餐厅</title>
      <link>https://hualet.org/blog/2016/12/05/%E6%A5%BC%E5%85%B0%E9%A4%90%E5%8E%85/</link>
      <pubDate>Mon, 05 Dec 2016 21:26:48 +0800</pubDate>
      
      <guid>https://hualet.org/blog/2016/12/05/%E6%A5%BC%E5%85%B0%E9%A4%90%E5%8E%85/</guid>
      <description>这个星期有点浪过头了，周六出去打了羽毛球，周日又出去觅食，文章呢？代码呢？sigh……不过周日的觅食还颇为成功，倒是可以叙叙，补补文章的缺。
楼兰餐厅，一个以新疆地域美食为主题的餐厅，是一个大口吃肉大口吃馕的地方，第一次听说还是上周偶然看到表姐的朋友圈，配图中的烤羊排看着烤得焦黄，卖相相当好，仅这一点便深深地吸引了我，遂决定这周即使浪过头也要去尝一尝。中午十二点到世界城五楼，果然要排长队等候，越加坚定了我这个餐厅不错的信念。
半小时后，终于可以进店享用美食，我俩食量不大，所以只点了四份菜（好像也不完全叫菜，不好称呼）， 因为是第一次来，所以菜都是根据感觉来点的，但是我感觉确实刚好凑出了一个比较好的搭配： 第一个上来的是酸奶哈密瓜： 可能是因为用餐环境比较热或者其他的缘故，酸爽的酸奶搭配香甜的哈密瓜，让人的味觉神经突然就活跃起来，人也精神多了；喝了两口小崔急忙制止：“烤羊排肥，吃了肉再喝酸奶，就不会觉得腻”。果然美食家呀，我心悦诚服，放下勺子。
很快，便等到今天的主角大漠烤羊排： 名字听了只让人联想到楼兰古国覆灭后的一片大漠，自古多少英雄战死的地方，想着略悲情，只能吃口烤羊排排解。话说这羊排真不错，外焦里嫩，不管是配酱汁还是佐料，都能让人食欲大开（跟着小崔吃了不少韩国烤肉，完全是两种风格）。吃了两块，大呼过瘾但是也略觉肥腻，这时候吃两口酸奶……写得我现在口水直流……
楼兰肉囊和牛肉汤揪面差不多是同时上的： 可能是本能上觉得饼和汤搭配吧，就像羊肉泡馍的汤和饼搭配一样，我们点这两样的时候相当默契。事实证明，小崔非常具有美食家的风范，饼是牛肉馅的，配有洋葱，虽然一点都不腻，但是搭配酸爽的牛肉汤，有更上一层楼的美感，肉馕和汤在嘴里相遇的那一刻，真有一种一辈子就这样罢的感觉。实话说，汤的配图有点失败，其实里面有面片一样的面和牛肉片，配有各种蔬菜丁，如果单卖的话我估计可以喝两碗 。
中间小崔也是乐的不得了，原来除了韩国烤肉，还有这么好吃的东西叻，我就顺势盗了她的一张“全餐图”： 食毕，买单走人！</description>
    </item>
    
    <item>
      <title>Things about kernel updates on deepin</title>
      <link>https://hualet.org/blog/2016/10/30/things-about-kernel-updates-on-deepin/</link>
      <pubDate>Sun, 30 Oct 2016 21:26:48 +0800</pubDate>
      
      <guid>https://hualet.org/blog/2016/10/30/things-about-kernel-updates-on-deepin/</guid>
      <description>There were discussions about kernel updates on both deepin forum and deepin telegram group. Users are curious about why security updates are always being lag on deepin, and why there&amp;rsquo;s no newer version kernel for so long. I explained it in telegram group, here I&amp;rsquo;ll do it again in case someone&amp;rsquo;s interested:
As we all know, deepin&amp;rsquo;s maintaining kernel by ourselves now, based on version 4.4 LTS, our kernel gets patches by our kernel team, from Debian and also from Ubuntu (Yes, we do!</description>
    </item>
    
    <item>
      <title>工作效率杀手-多任务并行</title>
      <link>https://hualet.org/blog/2016/10/27/%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E6%9D%80%E6%89%8B-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%B9%B6%E8%A1%8C/</link>
      <pubDate>Thu, 27 Oct 2016 21:26:48 +0800</pubDate>
      
      <guid>https://hualet.org/blog/2016/10/27/%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87%E6%9D%80%E6%89%8B-%E5%A4%9A%E4%BB%BB%E5%8A%A1%E5%B9%B6%E8%A1%8C/</guid>
      <description>日常工作中，我们经常会遇到手头有多项工作，而deadline在即的情况，这时候我们不得不变成三头六臂，多项工作同时进行：先找A商定一下协作前各自需要先完成的工作，再找B确定一下xxx，当要C工作进展到一半的时候，突然发现D工作更紧急一点，正要切换到D工作上，一个同事慢慢向你走过来，“忘记昨天我们说好今天开会的么”……
还好，如果最后你能撑过这段时间，你可能会赢得“高效能人士”的称号，你可能会被公司领导当众表扬，你也可能从此走上人生巅峰……但是请相信我，这些都是假象，当你在这种假象中高兴过几次以后，你突然发现自己效率急剧降低，精力集中不起来，脑子越来越不好使，浑浑噩噩，最后一发不可收拾。
为什么多任务并行最后会导致这么严重的后果呢？我认真思考了一下，感觉主要问题还是我们普通人的精力有限，压根儿承受不了两个以上任务同时进行。计算机专业有一个术语叫做“系统颠簸”，它通俗来讲是这样子的：
 就是当系统内存不够，而又有多个程序同时运行的时候，不活跃的程序会被放置到内存之外，当它再次变成活跃程序的时候，再将它换回到内存中，将另外的程序换出，当系统持续处于这种情况时，整个系统处于机器不稳定、不流畅的状态，就叫系统颠簸；
 而我们人类也有系统颠簸的情况，就像上面我说的。
自从我从一名普通的程序员变成管项目的程序员之后，多任务并行在我身上上演了无数次：同时担任项目经理、技术主管、程序员、四分之一个产品经理和十分之一个客服这几个角色；最开始还忙得乐此不疲，但是中国的一句老话说得好，“出来混迟早要还的”……一年多下来，我从一个精神饱满的小青年，眼睁睁就变成了现在目光呆滞、思维缓慢、精力极度不集中的小青年，饱受痛苦。
所以，我也一直在思考着如果才能从根本上杜绝这种多任务并行（被同事打扰也算）的发生，但是也请不要理解错误，并不是什么所有的任务都不能同时进行，比如《这样工作最高效》里面就介绍说，检查邮件和开会、编译代码和阅读文章 这样的例子是适合多任务并行的，只要不会让同事感到尴尬就行。那么如何很好地保护自己的工作效率不要被多任务并行给“杀”掉呢？
我想到的大概有两种方式：
 把时间分成小段 这种方式比较类似于番茄工作法，比如我们把一天的工作定为10个番茄中，每个番茄钟半小时，这半个小时中我们集中精力在一件事情上面，专注于这件工作直至它完成，每两个番茄钟之前有15分钟的休息时间，这段时间可以用来休息，也可以用来解决同事临时过来需要处理的紧急事情。这样一天下来，我们只要保证每个番茄钟内是非常高效的，这一天就能保证是高效。
 把时间分成大段 这种方式更简单，直接把上午定义为“杂碎期”，下午定义为“专注期”，“杂碎期”用于处理各种计划安排、闲聊、和同事沟通、开会等；“专注期”则专注于自己需要独立完成的工作，这段时间内不要受到任务打扰，保证工作的高效。
  总而言之，要让我们的大脑保持专注，而不是在不同的任务间切来切去；跟同事沟通好自己的时间安排，避免过多被打扰；做一个高效率的人。
差点忘了说，我目前正在践行第二种方式，目前感觉良好，希望也能帮到跟我有同样问题的人。</description>
    </item>
    
  </channel>
</rss>